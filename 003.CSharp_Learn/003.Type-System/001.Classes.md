# Classes
## Reference types
A type that is defined as a class is a reference type. At run time, when you declare a variable of a reference type, the variable contains the value null until you explicitly create an instance of the class by using the new operator, or assign it an object of a compatible type that may have been created elsewhere, as shown in the following example:(定义为class的类型是引用类型。在运行时，当声明引用类型的变量时，该变量包含值null，直到使用new操作符显式创建类的实例，或者为其分配一个可能在其他地方创建的兼容类型的对象，如下例所示:)
```C#
   //Declaring an object of type MyClass.
   MyClass mc = new MyClass();
   
   //Declaring another object of the same type, assigning it the value of the first object.
   MyClass mc2 = mc;
```

When the object is created, enough memory is allocated on the managed heap for that specific object, and the variable holds only a reference to the location of said object. The memory used by an object is reclaimed by the automatic memory management functionality of the CLR, which is known as garbage collection. For more information about garbage collection, see [Automatic memory management and garbage collection](./../../004.DotNet/000.Automatic%20memory%20management%20and%20garbage%20collection/README.md).(在创建对象时，在托管堆上为该特定对象分配足够的内存，并且变量仅保存对该对象位置的引用。对象使用的内存由CLR的自动内存管理功能回收，这称为垃圾收集。有关垃圾收集的详细信息，请参见[自动内存管理和垃圾收集](./../../004.DotNet/000.Automatic%20memory%20management%20and%20garbage%20collection/README.md)。)

## Declaring classes
Classes are declared by using the class keyword followed by a unique identifier, as shown in the following example:
```C#
     //[access modifier] - [class] - [identifier]
     public class Customer
     {
        // Fields, properties, methods and events go here...
     }
```

An optional access modifier precedes the class keyword. Because public is used in this case, anyone can create instances of this class. The name of the class follows the class keyword. The name of the class must be a valid C# identifier name. The remainder of the definition is the class body, where the behavior and data are defined. Fields, properties, methods, and events on a class are collectively referred to as class members.(在class关键字之前有一个可选的访问修饰符。因为在这种情况下使用了public，所以任何人都可以创建该类的实例。类的名称跟在class关键字后面。类的名称必须是一个有效的c#标识符名称。定义的其余部分是类主体，其中定义了行为和数据。类上的字段、属性、方法和事件统称为类成员。)

## Creating objects
Although they're sometimes used interchangeably, a class and an object are different things. A class defines a type of object, but it isn't an object itself. An object is a concrete entity based on a class, and is sometimes referred to as an instance of a class.(虽然它们有时可以互换使用，但类和对象是不同的东西。类定义了对象的类型，但它本身不是对象。对象是基于类的具体实体，有时也称为类的实例。)

Objects can be created by using the new keyword followed by the name of the class, like this:
```C#
    Customer object1 = new Customer();
```

When an instance of a class is created, a reference to the object is passed back to the programmer. In the previous example, object1 is a reference to an object that is based on Customer. This reference refers to the new object but doesn't contain the object data itself. In fact, you can create an object reference without creating an object at all:(当一个类的实例被创建时，对该对象的引用被传递给程序员。在前面的示例中，object1是对基于Customer的对象的引用。此引用引用新对象，但不包含对象数据本身。实际上，你可以在不创建对象的情况下创建对象引用:)
```C#
   Customer object2;
```

We don't recommend creating object references that don't refer to an object because trying to access an object through such a reference fails at run time. A reference can be made to refer to an object, either by creating a new object, or by assigning it an existing object, such as this:(我们不建议创建不引用对象的对象引用，因为试图通过这样的引用访问对象会在运行时失败。可以通过创建新对象或将其分配给现有对象来引用对象，例如:)
```C#
     Customer object3 = new Customer();
     Customer object4 = object3;
```

This code creates two object references that both refer to the same object. Therefore, any changes to the object made through object3 are reflected in subsequent uses of object4. Because objects that are based on classes are referred to by reference, classes are known as reference types.(这段代码创建了两个对象引用，它们都指向同一个对象。因此，通过object3对对象所做的任何更改都会反映在object4的后续使用中。因为基于类的对象是通过引用来引用的，所以类被称为引用类型。)

## Constructors and initialization
The preceding sections introduced the syntax to declare a class type and create an instance of that type. When you create an instance of a type, you want to ensure that its fields and properties are initialized to useful values. There are several ways to initialize values:(前面几节介绍了声明类类型和创建该类型实例的语法。当您创建类型的实例时，您希望确保将其字段和属性初始化为有用的值。有几种方法可以初始化值:)
- Accept default values
- Field initializers
- Constructor parameters
- Object initializers

Every .NET type has a default value. Typically, that value is 0 for number types, and null for all reference types. You can rely on that default value when it's reasonable in your app.(每个.net类型都有一个默认值。通常，对于数字类型该值为0，对于所有引用类型该值为null。当它在应用中合理时，你可以依赖这个默认值。)

When the .NET default isn't the right value, you can set an initial value using a field initializer:(字段初始化)
```C#
   public class Container
   {
       // Initialize capacity field to a default value of 10:
       private int _capacity = 10;
   }
```

You can require callers to provide an initial value by defining a constructor that's responsible for setting that initial value:(你可以通过定义一个负责设置初始值的构造函数来要求调用者提供一个初始值:)
```C#
   public class Container
   {
       private int _capacity;
   
       public Container(int capacity) => _capacity = capacity;
   }
```

Beginning with C# 12, you can define a primary constructor as part of the class declaration:
```C#
   public class Container(int capacity)
   {
       private int _capacity = capacity;
   }
```

Adding parameters to the class name defines the primary constructor. Those parameters are available in the class body, which includes its members. You can use them to initialize fields or anywhere else where they're needed.(向类名添加参数定义主构造函数。这些参数在类主体中可用，类主体包括类的成员。您可以使用它们来初始化字段或其他需要它们的地方。)

You can also use the required modifier on a property and allow callers to use an object initializer to set the initial value of the property(你也可以在属性上使用必需的修饰符，并允许调用者使用对象初始化器来设置属性的初始值:)
```C#
   public class Person
   {
       public required string LastName { get; set; }
       public required string FirstName { get; set; }
   }

   // The addition of the required keyword mandates that callers must set those properties as part of a new expression:(required关键字的添加要求调用者必须将这些属性设置为new表达式的一部分:)
   
   var p1 = new Person(); // Error! Required properties not set
   var p2 = new Person() { FirstName = "Grace", LastName = "Hopper" };
```

## Class inheritance
Classes fully support inheritance, a fundamental characteristic of object-oriented programming. When you create a class, you can inherit from any other class that isn't defined as sealed. Other classes can inherit from your class and override class virtual methods. Furthermore, you can implement one or more interfaces.(类完全支持继承，这是面向对象编程的基本特征。当您创建一个类时，您可以从没有定义为密封的任何其他类继承。其他类可以继承您的类并重写类的虚方法。此外，您可以实现一个或多个接口。)
> 虚方法,C#语法是怎样的

Inheritance is accomplished by using a derivation, which means a class is declared by using a base class from which it inherits data and behavior. A base class is specified by appending a colon and the name of the base class following the derived class name, like this:(继承是通过使用派生来完成的，这意味着一个类是通过使用基类来声明的，它从基类继承数据和行为。通过在派生类名后面附加冒号和基类名来指定基类，如下所示:)
```C#
    public class Manager : Employee
    {
        // Employee fields, properties, methods and events are inherited
        // New Manager fields, properties, methods and events go here...
    }
```

When a class declaration includes a base class, it inherits all the members of the base class except the constructors. For more information, see [Inheritance](./004.C#-Inheritance.md).(当类声明包含基类时，它继承基类的所有成员，除了构造函数。有关更多信息，请参见[继承](./004.C#-Inheritance.md)。)

A class in C# can only directly inherit from one base class. However, because a base class may itself inherit from another class, a class might indirectly inherit multiple base classes. Furthermore, a class can directly implement one or more interfaces. For more information, see [Interfaces](./005.C#-Interfaces.md).(c#中的一个类只能直接继承一个基类。但是，因为基类本身可以继承另一个类，所以一个类可以间接继承多个基类。此外，一个类可以直接实现一个或多个接口。有关更多信息，请参见[接口](./005.C#-Interfaces.md)。)
> 单继承，多实现

A class can be declared as [abstract](./006.C#-Abstract.md). An abstract class contains abstract methods that have a signature definition but no implementation. Abstract classes can't be instantiated. They can only be used through derived classes that implement the abstract methods. By contrast, a sealed class doesn't allow other classes to derive from it. For more information, see [Abstract and Sealed Classes and Class Members](./007.C#-Abstract%20and%20Sealed%20Classes%20and%20Class%20Members.md).(类可以声明为抽象类。抽象类包含具有签名定义但没有实现的抽象方法。抽象类不能被实例化。它们只能通过实现抽象方法的派生类来使用。相比之下，密封类不允许其他类从它派生。有关更多信息，请参见抽象和密封类以及类成员。)

## 参考资料
1. [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)

