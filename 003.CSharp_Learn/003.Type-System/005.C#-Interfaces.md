# Interfaces - define behavior for multiple types
An interface contains definitions for a group of related functionalities that a non-abstract class or a struct must implement. An interface may define static methods, which must have an implementation. An interface may define a default implementation for members. An interface may not declare instance data such as fields, auto-implemented properties, or property-like events.(接口包含非抽象类或结构必须实现的一组相关功能的定义。接口可以定义静态方法，这些方法必须有实现。接口可以为成员定义默认实现。接口不能声明实例数据，如字段、自动实现的属性或类似属性的事件。)

By using interfaces, you can, for example, include behavior from multiple sources in a class. That capability is important in C# because the language doesn't support multiple inheritance of classes. In addition, you must use an interface if you want to simulate inheritance for structs, because they can't actually inherit from another struct or class.(例如，通过使用接口，您可以在一个类中包含来自多个源的行为。这个功能在c#中很重要，因为该语言不支持类的多重继承。此外，如果希望模拟结构的继承，则必须使用接口，因为它们实际上不能从另一个结构或类继承。)

You define an interface by using the interface keyword as the following example shows.(使用interface关键字定义接口，示例如下。)
```C#
  interface IEquatable<T>
  {
      bool Equals(T obj);
  }
```

The name of an interface must be a valid C# identifier name. By convention, interface names begin with a capital I.(接口的名称必须是一个有效的c#标识符名称。按照惯例，接口名称以大写I开头。)

Any class or struct that implements the IEquatable\<T> interface must contain a definition for an Equals method that matches the signature that the interface specifies. As a result, you can count on a class that implements IEquatable\<T> to contain an Equals method with which an instance of the class can determine whether it's equal to another instance of the same class.(任何实现了IEquatable\<T>接口的类或结构都必须包含一个与接口指定的签名相匹配的Equals方法的定义。因此，可以指望实现了IEquatable\<T>的类包含一个Equals方法，该类的实例可以通过该方法确定它是否等于同一类的另一个实例。)

The definition of IEquatable\<T> doesn't provide an implementation for Equals. A class or struct can implement multiple interfaces, but a class can only inherit from a single class.(IEquatable\<T>的定义没有提供等价的实现。一个类或结构可以实现多个接口，但一个类只能继承一个类。)

Interfaces can contain instance methods, properties, events, indexers, or any combination of those four member types. Interfaces may contain static constructors, fields, constants, or operators. Beginning with C# 11, interface members that aren't fields may be static abstract. An interface can't contain instance fields, instance constructors, or finalizers. Interface members are public by default, and you can explicitly specify accessibility modifiers, such as public, protected, internal, private, protected internal, or private protected. A private member must have a default implementation.(接口可以包含实例方法、属性、事件、索引器或这四种成员类型的任意组合。接口可以包含静态构造函数、字段、常量或操作符。从c# 11开始，不是字段的接口成员可以是静态抽象的。接口不能包含实例字段、实例构造函数或终结器。默认情况下，接口成员是公共的，您可以显式指定可访问性修饰符，例如public、protected、internal、private、protected internal或private protected。私有成员必须具有默认实现。)

To implement an interface member, the corresponding member of the implementing class must be public, non-static, and have the same name and signature as the interface member.(要实现接口成员，实现类的相应成员必须是公共的、非静态的，并且具有与接口成员相同的名称和签名。)

When an interface declares static members, a type implementing that interface may also declare static members with the same signature. Those are distinct and uniquely identified by the type declaring the member. The static member declared in a type doesn't override the static member declared in the interface.(当接口声明静态成员时，实现该接口的类型也可以声明具有相同签名的静态成员。它们是不同的，由声明成员的类型唯一标识。在类型中声明的静态成员不会覆盖在接口中声明的静态成员。)

A class or struct that implements an interface must provide an implementation for all declared members without a default implementation provided by the interface. However, if a base class implements an interface, any class that's derived from the base class inherits that implementation.(实现接口的类或结构必须为所有声明的成员提供实现，而不需要接口提供默认实现。但是，如果基类实现了接口，则从基类派生的任何类都继承该实现。)

```C#
// The following example shows an implementation of the IEquatable<T> interface. The implementing class, Car, must provide an implementation of the Equals method.

  public class Car : IEquatable<Car>
  {
      public string? Make { get; set; }
      public string? Model { get; set; }
      public string? Year { get; set; }
  
      // Implementation of IEquatable<T> interface
      public bool Equals(Car? car)
      {
          return (this.Make, this.Model, this.Year) ==
              (car?.Make, car?.Model, car?.Year);
      }
  }
```

Properties and indexers of a class can define extra accessors for a property or indexer that's defined in an interface. For example, an interface might declare a property that has a get accessor. The class that implements the interface can declare the same property with both a get and set accessor. However, if the property or indexer uses explicit implementation, the accessors must match. For more information about explicit implementation, see Explicit Interface Implementation and Interface Properties.（类的属性和索引器可以为接口中定义的属性或索引器定义额外的访问器。例如，接口可以声明具有get访问器的属性。实现接口的类可以使用get和set访问器声明相同的属性。但是，如果属性或索引器使用显式实现，则访问器必须匹配。有关显式实现的详细信息，请参见显式接口实现和接口属性。）

Interfaces can inherit from one or more interfaces. The derived interface inherits the members from its base interfaces. A class that implements a derived interface must implement all members in the derived interface, including all members of the derived interface's base interfaces. That class may be implicitly converted to the derived interface or any of its base interfaces. A class might include an interface multiple times through base classes that it inherits or through interfaces that other interfaces inherit. However, the class can provide an implementation of an interface only one time and only if the class declares the interface as part of the definition of the class (class ClassName : InterfaceName). If the interface is inherited because you inherited a base class that implements the interface, the base class provides the implementation of the members of the interface. However, the derived class can reimplement any virtual interface members instead of using the inherited implementation. When interfaces declare a default implementation of a method, any class implementing that interface inherits that implementation (You need to cast the class instance to the interface type to access the default implementation on the Interface member).(接口可以从一个或多个接口继承。派生接口从其基接口继承成员。实现派生接口的类必须实现派生接口中的所有成员，包括派生接口基接口的所有成员。该类可以隐式地转换为派生接口或其任何基接口。一个类可以通过它继承的基类或通过其他接口继承的接口多次包含一个接口。然而，类只能提供一次接口的实现，并且只有当类将接口声明为类定义的一部分时(类ClassName: InterfaceName)。如果由于继承了实现接口的基类而继承了接口，则基类提供接口成员的实现。但是，派生类可以重新实现任何虚接口成员，而不是使用继承的实现。当接口声明方法的默认实现时，实现该接口的任何类都继承该实现(您需要将类实例强制转换为接口类型以访问interface成员上的默认实现)。)


## Interfaces summary
An interface has the following properties:
- In C# versions earlier than 8.0, an interface is like an abstract base class with only abstract members. A class or struct that implements the interface must implement all its members.(在8.0之前的c#版本中，接口就像一个只有抽象成员的抽象基类。实现接口的类或结构必须实现其所有成员。)
- Beginning with C# 8.0, an interface may define default implementations for some or all of its members. A class or struct that implements the interface doesn't have to implement members that have default implementations. For more information, see [default interface methods](https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/interface-implementation/default-interface-methods-versions).(从c# 8.0开始，接口可以为其部分或全部成员定义默认实现。实现接口的类或结构不必实现具有默认实现的成员。)
- An interface can't be instantiated directly. Its members are implemented by any class or struct that implements the interface.(接口不能直接实例化。它的成员由实现接口的任何类或结构实现。)
- A class or struct can implement multiple interfaces. A class can inherit a base class and also implement one or more interfaces.(一个类或结构可以实现多个接口。类可以继承基类，也可以实现一个或多个接口。)





## 参考资料
1. [Interfaces - define behavior for multiple types](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/interfaces)