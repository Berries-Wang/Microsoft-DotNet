# Inheritance (继承)
Inheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming. Inheritance enables you to create new classes that reuse, extend, and modify the behavior defined in other classes. The class whose members are inherited is called the base class, and the class that inherits those members is called the derived class. A derived class can have only one direct base class. However, inheritance is transitive. If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.(继承、封装和多态性是面向对象编程的三个主要特征之一。继承使您能够创建重用、扩展和修改在其他类中定义的行为的新类。继承其成员的类称为基类，继承这些成员的类称为派生类。派生类只能有一个直接基类。然而，继承是可传递的。如果ClassC从ClassB派生，而ClassB从ClassA派生，则ClassC继承在ClassB和ClassA中声明的成员。)

When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and finalizers. The derived class reuses the code in the base class without having to reimplement it. You can add more members in the derived class. The derived class extends the functionality of the base class.(当定义要从另一个类派生的类时，派生类隐式地获得基类的所有成员，但构造函数和终结器除外。派生类重用基类中的代码，而不必重新实现它。可以在派生类中添加更多成员。派生类扩展基类的功能。)

The following illustration shows a class WorkItem that represents an item of work in some business process. Like all classes, it derives from System.Object and inherits all its methods. WorkItem adds six members of its own. These members include a constructor, because constructors aren't inherited. Class ChangeRequest inherits from WorkItem and represents a particular kind of work item. ChangeRequest adds two more members to the members that it inherits from WorkItem and from Object. It must add its own constructor, and it also adds originalItemID. Property originalItemID enables the ChangeRequest instance to be associated with the original WorkItem to which the change request applies.(下面的插图显示了一个类WorkItem，它表示某个业务流程中的工作项。像所有类一样，它派生自System.Object 并继承其所有方法。WorkItem添加它自己的六个成员。这些成员包括一个构造函数，因为构造函数不能被继承。类ChangeRequest继承自WorkItem，并表示一种特定类型的工作项。ChangeRequest向它从WorkItem和Object继承的成员中添加了另外两个成员。它必须添加自己的构造函数，并且还添加了originalItemID。属性originalItemID使ChangeRequest实例能够与变更请求应用的原始工作项相关联。)
![class-inheritance-diagram.png](./IMGS/class-inheritance-diagram.png)

The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#. The example also shows how WorkItem overrides the virtual method Object.ToString, and how the ChangeRequest class inherits the WorkItem implementation of the method. The first block defines the classes:(下面的示例展示了如何在c#中表达前面插图中演示的类关系。该示例还显示了WorkItem如何覆盖虚拟方法Object.ToString，以及ChangeRequest类如何继承该方法的WorkItem实现。第一个块定义了类:)
```C#
// WorkItem implicitly inherits from the Object class.
public class WorkItem
{
    // Static field currentID stores the job ID of the last WorkItem that
    // has been created.
    private static int currentID;

    //Properties.
    protected int ID { get; set; }
    protected string Title { get; set; }
    protected string Description { get; set; }
    protected TimeSpan jobLength { get; set; }

    // Default constructor. If a derived class does not invoke a base-
    // class constructor explicitly, the default constructor is called
    // implicitly.
    public WorkItem()
    {
        ID = 0;
        Title = "Default title";
        Description = "Default description.";
        jobLength = new TimeSpan();
    }

    // Instance constructor that has three parameters.
    public WorkItem(string title, string desc, TimeSpan joblen)
    {
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = joblen;
    }

    // Static constructor to initialize the static member, currentID. This
    // constructor is called one time, automatically, before any instance
    // of WorkItem or ChangeRequest is created, or currentID is referenced.
    static WorkItem() => currentID = 0;

    // currentID is a static field. It is incremented each time a new
    // instance of WorkItem is created.
    protected int GetNextID() => ++currentID;

    // Method Update enables you to update the title and job length of an
    // existing WorkItem object.
    public void Update(string title, TimeSpan joblen)
    {
        this.Title = title;
        this.jobLength = joblen;
    }

    // Virtual method override of the ToString method that is inherited
    // from System.Object.
    public override string ToString() =>
        $"{this.ID} - {this.Title}";
}

// ChangeRequest derives from WorkItem and adds a property (originalItemID)
// and two constructors.
public class ChangeRequest : WorkItem
{
    protected int originalItemID { get; set; }

    // Constructors. Because neither constructor calls a base-class
    // constructor explicitly, the default constructor in the base class
    // is called implicitly. The base class must contain a default
    // constructor.

    // Default constructor for the derived class.
    public ChangeRequest() { }

    // Instance constructor that has four parameters.
    public ChangeRequest(string title, string desc, TimeSpan jobLen,
                         int originalID)
    {
        // The following properties and the GetNexID method are inherited
        // from WorkItem.
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = jobLen;

        // Property originalItemID is a member of ChangeRequest, but not
        // of WorkItem.
        this.originalItemID = originalID;
    }
}
```

This next block shows how to use the base and derived classes:
```C#

// Create an instance of WorkItem by using the constructor in the
// base class that takes three arguments.
WorkItem item = new WorkItem("Fix Bugs",
                            "Fix all bugs in my code branch",
                            new TimeSpan(3, 4, 0, 0));

// Create an instance of ChangeRequest by using the constructor in
// the derived class that takes four arguments.
ChangeRequest change = new ChangeRequest("Change Base Class Design",
                                        "Add members to the class",
                                        new TimeSpan(4, 0, 0),
                                        1);

// Use the ToString method defined in WorkItem.
Console.WriteLine(item.ToString());

// Use the inherited Update method to change the title of the
// ChangeRequest object.
change.Update("Change the Design of the Base Class",
    new TimeSpan(4, 0, 0));

// ChangeRequest inherits WorkItem's override of ToString.
Console.WriteLine(change.ToString());
/* Output:
    1 - Fix Bugs
    2 - Change the Design of the Base Class
*/

```

## Abstract and virtual methods
When a base class declares a method as virtual, a derived class can override the method with its own implementation. If a base class declares a member as abstract, that method must be overridden in any non-abstract class that directly inherits from that class. If a derived class is itself abstract, it inherits abstract members without implementing them. Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming. For more information, see Polymorphism.(当基类将方法声明为虚方法时，派生类可以用自己的实现覆盖该方法。如果基类将成员声明为抽象，则必须在直接继承该类的任何非抽象类中重写该方法。如果派生类本身是抽象的，则继承抽象成员而不实现它们。抽象成员和虚成员是多态的基础，多态是面向对象编程的第二个主要特征。有关更多信息，请参见多态性。)


## Abstract base classes
You can declare a class as abstract if you want to prevent direct instantiation by using the new operator. An abstract class can be used only if a new class is derived from it. An abstract class can contain one or more method signatures that themselves are declared as abstract. These signatures specify the parameters and return value but have no implementation (method body). An abstract class doesn't have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract. Derived classes that aren't abstract themselves must provide the implementation for any abstract methods from an abstract base class.(如果希望通过使用new操作符来防止直接实例化，可以将类声明为抽象类。抽象类只有在派生出新类时才能使用。抽象类可以包含一个或多个本身被声明为抽象的方法签名。这些签名指定参数和返回值，但没有实现(方法体)。抽象类不必包含抽象成员;但是，如果类确实包含抽象成员，则必须将类本身声明为抽象。本身不是抽象的派生类必须为来自抽象基类的任何抽象方法提供实现。)
```C#
   1. 抽象成员 是什么意思

```

## Interfaces
An interface is a reference type that defines a set of members. All classes and structs that implement that interface must implement that set of members. An interface may define a default implementation for any or all of these members. A class can implement multiple interfaces even though it can derive from only a single direct base class.(接口是定义一组成员的引用类型。所有实现该接口的类和结构都必须实现该成员集。接口可以为任何或所有这些成员定义默认实现。一个类可以实现多个接口，即使它只能从一个直接基类派生。)

Interfaces are used to define specific capabilities for classes that don't necessarily have an "is a" relationship. For example, the System.IEquatable\<T\> interface can be implemented by any class or struct to determine whether two objects of the type are equivalent (however the type defines equivalence). IEquatable\<T\> doesn't imply the same kind of "is a" relationship that exists between a base class and a derived class (for example, a Mammal is an Animal). For more information, see Interfaces.


## Preventing further derivation
A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as sealed.(一个类可以通过将自己或成员声明为密封来防止其他类从它或它的任何成员继承。)
```C#
  
```

## Derived class hiding of base class members
A derived class can hide base class members by declaring members with the same name and signature. The new modifier can be used to explicitly indicate that the member isn't intended to be an override of the base member. The use of new isn't required, but a compiler warning will be generated if new isn't used. For more information, see Versioning with the Override and New Keywords and Knowing When to Use Override and New Keywords.(派生类可以通过声明具有相同名称和签名的成员来隐藏基类成员。新的修饰符可用于显式地指示成员不打算作为基成员的重写。不需要使用new，但如果不使用new，将生成一个编译器警告。有关详细信息，请参见使用覆盖和新关键字进行版本控制和了解何时使用覆盖和新关键字。)

---
## Knowing When to Use Override and New Keywords
> 方法的分派与调用

In C#, a method in a derived class can have the same name as a method in the base class. You can specify how the methods interact by using the new and override keywords. The override modifier extends the base class virtual method, and the new modifier hides an accessible base class method. The difference is illustrated in the examples in this topic.(在c#中，派生类中的方法可以与基类中的方法具有相同的名称。您可以通过使用new和override关键字来指定方法的交互方式。重写修饰符扩展基类虚方法，新修饰符隐藏可访问的基类方法。本主题中的示例说明了它们之间的区别。)

In a console application, declare the following two classes, BaseClass and DerivedClass. DerivedClass inherits from BaseClass.
```C#
 
   class BaseClass  
   {  
       public void Method1()  
       {  
           Console.WriteLine("Base - Method1");  
       }  
   }  
     
   class DerivedClass : BaseClass  
   {  
       public void Method2()  
       {  
           Console.WriteLine("Derived - Method2");  
       }  
   }

```

In the Main method, declare variables bc, dc, and bcdc.
- bc is of type BaseClass, and its value is of type BaseClass.
- dc is of type DerivedClass, and its value is of type DerivedClass.
- bcdc is of type BaseClass, and its value is of type DerivedClass. This is the variable to pay attention to.

Because bc and bcdc have type BaseClass, they can only directly access Method1, unless you use casting. Variable dc can access both Method1 and Method2. These relationships are shown in the following code.

```C#
class Program  
{  
    static void Main(string[] args)  
    {  
        BaseClass bc = new BaseClass();  
        DerivedClass dc = new DerivedClass();  
        BaseClass bcdc = new DerivedClass();  
  
        bc.Method1();  
        dc.Method1();  
        dc.Method2();  
        bcdc.Method1();  
    }  
    // Output:  
    // Base - Method1  
    // Base - Method1  
    // Derived - Method2  
    // Base - Method1  
}
```

Next, add the following Method2 method to BaseClass. The signature of this method matches the signature of the Method2 method in DerivedClass.
```C#
  public void Method2()  
  {  
      Console.WriteLine("Base - Method2");  
  }
```

Because BaseClass now has a Method2 method, a second calling statement can be added for BaseClass variables bc and bcdc, as shown in the following code.
```C#
  bc.Method1();  
  bc.Method2();  
  dc.Method1();  
  dc.Method2();  
  bcdc.Method1();  
  bcdc.Method2();
```
When you build the project, you see that the addition of the Method2 method in BaseClass causes a warning. The warning says that the Method2 method in DerivedClass hides the Method2 method in BaseClass. You are advised to use the new keyword in the Method2 definition if you intend to cause that result. Alternatively, you could rename one of the Method2 methods to resolve the warning, but that is not always practical.
```C#
   // 当运行的时候，会输出一个警告：
   wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
   /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/Program_2.cs(38,17): warning CS0108: 'DerivedClass.Method2()' hides inherited member 'BaseClass.Method2()'. Use the new keyword if hiding was intended. [/home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/CSharp_Grammar_01.csproj]
   Base - Method1
   Base - Method2
   Base - Method1
   Derived - Method2 
   Base - Method1  
   Base - Method2 // 变量类型 BaseClass 变量值类型:DerivedClass
   // 即，提示使用new关键字去隐藏继承而来的BaseClass.Method2方法
   // 通过输出可以发现，对比dc.Method2(); ,此时方法的接收者绑定是根据变量的类型来的（类比: 004.OpenJDK(JVM)学习/011.执行与优化/003.Java与动态类型.md），而不是根据变量值的类型来绑定的
```

The new keyword preserves the relationships that produce that output, but it suppresses the warning. The variables that have type BaseClass continue to access the members of BaseClass, and the variable that has type DerivedClass continues to access members in DerivedClass first, and then to consider members inherited from BaseClass.(new关键字保留了产生该输出的关系，但它抑制了警告。具有BaseClass类型的变量继续访问BaseClass的成员，具有DerivedClass类型的变量继续首先访问DerivedClass中的成员，然后考虑从BaseClass继承的成员。)
> 即添加了new关键字，方法的接收者的绑定关系不会变

To suppress the warning, add the new modifier to the definition of Method2 in DerivedClass, as shown in the following code. The modifier can be added before or after public.(要抑制警告，将新的修饰符添加到DerivedClass中的Method2定义中，如下面的代码所示。修饰符可以在public之前或之后添加。)

```C#
  public new void Method2()  
  {  
      Console.WriteLine("Derived - Method2");  
  }

  // 再次执行，无警告
  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
  Base - Method1
  Base - Method2
  Base - Method1
  Derived - Method2
  Base - Method1
  Base - Method2
```

To contrast(对比) this behavior to the effects of using override, add the following method to DerivedClass. The override modifier can be added before or after public.
```C#
public override void Method1()  
{  
    Console.WriteLine("Derived - Method1");  
}
// 直接运行报错: 
wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
/home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/Program_2.cs(43,26): error CS0506: 'DerivedClass.Method1()': cannot override inherited member 'BaseClass.Method1()' because it is not marked virtual, abstract, or override [/home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/CSharp_Grammar_01.csproj]

The build failed. Fix the build errors and run again.
wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ 
```

Add the virtual modifier to the definition of Method1 in BaseClass. The virtual modifier can be added before or after public.
```C#
   public virtual void Method1()  
  {  
      Console.WriteLine("Base - Method1");  
  }

  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
  Base - Method1
  Base - Method2
  Derived - Method1
  Derived - Method2
  Derived - Method1
  Base - Method2
  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ 
```

The use of the override modifier enables bcdc to access the Method1 method that is defined in DerivedClass. Typically, that is the desired behavior in inheritance hierarchies. You want objects that have values that are created from the derived class to use the methods that are defined in the derived class. You achieve that behavior by using override to extend the base class method.(override修饰符的使用使bcdc能够访问在DerivedClass中定义的Method1方法。通常，这是继承层次结构中所期望的行为。您希望具有从派生类创建的值的对象使用派生类中定义的方法。您可以通过使用override来扩展基类方法来实现该行为。)
> override 修饰符符合Java继承规范,new修饰符是根据变量类型来绑定方法接受者;override是在运行时根据变量值类型来绑定方法接收者的

### new override 修饰符完整示例
```C#
namespace Wei;

public class HelloMain
{
    static int Main(string[] args)
    {
        BaseClass bc = new BaseClass();
        DerivedClass dc = new DerivedClass();
        BaseClass bcdc = new DerivedClass();

        bc.Method1();
        bc.Method2();
        dc.Method1();
        dc.Method2();
        bcdc.Method1();
        bcdc.Method2();

        return 0;
    }

}

class BaseClass
{
    public virtual void Method1()
    {
        Console.WriteLine("Base - Method1");
    }

    public virtual void Method2()
    {
        Console.WriteLine("Base - Method2");
    }
}

class DerivedClass : BaseClass
{
    public new void Method2()
    {
        Console.WriteLine("Derived - Method2");
    }

    public override void Method1()
    {
        Console.WriteLine("Derived - Method1");
    }
}
  
  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
  Base - Method1
  Base - Method2
  Derived - Method1
  Derived - Method2
  Derived - Method1
  Base - Method2
```

---


## Versioning with the Override and New Keywords
> 方法的分派与调用2.0

The C# language is designed so that versioning between base and derived classes in different libraries can evolve and maintain backward compatibility. This means, for example, that the introduction of a new member in a base class with the same name as a member in a derived class is completely supported by C# and does not lead to unexpected behavior. It also means that a class must explicitly state whether a method is intended to override an inherited method, or whether a method is a new method that hides a similarly named inherited method.(c#语言的设计使得不同库中的基类和派生类之间的版本控制可以发展并保持向后兼容性。这意味着，例如，在基类中引入与派生类中成员同名的新成员是完全由c#支持的，并且不会导致意外行为。这也意味着一个类必须显式地声明一个方法是打算覆盖一个继承方法，还是一个方法是隐藏了一个类似命名的继承方法的新方法。)

In C#, derived classes can contain methods with the same name as base class methods.

- If the method in the derived class is not preceded by new or override keywords, the compiler will issue a warning and the method will behave as if the new keyword were present.(如果派生类中的方法前面没有new或override关键字，编译器将发出警告，并且该方法将表现得好像存在new关键字一样。)
- If the method in the derived class is preceded with the new keyword, the method is defined as being independent of the method in the base class.(如果派生类中的方法前面带有new关键字，则该方法被定义为独立于基类中的方法。)
- If the method in the derived class is preceded with the override keyword, objects of the derived class will call that method instead of the base class method.(如果派生类中的方法前面有override关键字，则派生类的对象将调用该方法而不是基类方法。)
- In order to apply the override keyword to the method in the derived class, the base class method must be defined virtual.(为了将override关键字应用于派生类中的方法，必须将基类方法定义为virtual。)
- !!!-> The base class method can be called from within the derived class using the base keyword.(可以使用base关键字从派生类内部调用基类方法。)
- The override, virtual, and new keywords can also be applied to properties, indexers, and events.(override、virtual和new关键字还可以应用于属性、索引器和事件。)


By default, C# methods are not virtual. If a method is declared as virtual, any class inheriting the method can implement its own version. To make a method virtual, the virtual modifier is used in the method declaration of the base class. The derived class can then override the base virtual method by using the override keyword or hide the virtual method in the base class by using the new keyword. If neither the override keyword nor the new keyword is specified, the compiler will issue a warning and the method in the derived class will hide the method in the base class.(默认情况下，c#方法不是虚拟的。如果将方法声明为虚方法，则继承该方法的任何类都可以实现自己的版本。要使方法成为虚方法，可以在基类的方法声明中使用虚修饰符。然后，派生类可以使用override关键字重写基虚拟方法，或者使用new关键字将虚拟方法隐藏在基类中。如果既没有指定override关键字，也没有指定new关键字，编译器将发出警告，派生类中的方法将隐藏基类中的方法。​)

To demonstrate this in practice, assume for a moment that Company A has created a class named GraphicsClass, which your program uses. The following is GraphicsClass:
```C#
   class GraphicsClass
   {
       public virtual void DrawLine() { }
       public virtual void DrawPoint() { }
   }
```

Your company uses this class, and you use it to derive your own class, adding a new method:
```C#
class YourDerivedGraphicsClass : GraphicsClass
{
    public void DrawRectangle() { }
}
```

Your application is used without problems, until Company A releases a new version of GraphicsClass, which resembles(就像) the following code:
```C#
class GraphicsClass
{
    public virtual void DrawLine() { }
    public virtual void DrawPoint() { }
    public virtual void DrawRectangle() { }
}
```

The new version of GraphicsClass now contains a method named DrawRectangle. Initially, nothing occurs. The new version is still binary compatible with the old version. Any software that you have deployed will continue to work, even if the new class is installed on those computer systems. Any existing calls to the method DrawRectangle will continue to reference your version, in your derived class.(新版本的GraphicsClass现在包含一个名为DrawRectangle的方法。最初，什么都没有发生。新版本仍然与旧版本二进制兼容。您已经部署的任何软件都将继续工作，即使在这些计算机系统上安装了新类。对DrawRectangle方法的任何现有调用将继续在派生类中引用您的版本。)

However, as soon as you recompile your application by using the new version of GraphicsClass, you will receive a warning from the compiler, CS0108. This warning informs you that you have to consider how you want your DrawRectangle method to behave in your application.(但是，只要使用GraphicsClass的新版本重新编译应用程序，就会收到来自编译器CS0108的警告。这个警告告诉你，你必须考虑你希望你的DrawRectangle方法在你的应用程序中如何表现。)

If you want your method to override the new base class method, use the override keyword:
```C#
class YourDerivedGraphicsClass : GraphicsClass
{
    public override void DrawRectangle() { }
}
```

The override keyword makes sure that any objects derived from YourDerivedGraphicsClass will use the derived class version of DrawRectangle. Objects derived from YourDerivedGraphicsClass can still access the base class version of DrawRectangle by using the base keyword:
```C#
base.DrawRectangle();
```

If you do not want your method to override the new base class method, the following considerations apply. To avoid confusion between the two methods, you can rename your method. This can be time-consuming and error-prone, and just not practical in some cases. However, if your project is relatively small, you can use Visual Studio's Refactoring options to rename the method.(如果您不希望您的方法覆盖新的基类方法，则应用以下注意事项。为了避免这两个方法之间的混淆，您可以重命名您的方法。这可能非常耗时且容易出错，而且在某些情况下并不实用。但是，如果您的项目相对较小，则可以使用Visual Studio的Refactoring选项来重命名该方法)

Alternatively, you can prevent the warning by using the keyword new in your derived class definition:
```C#
class YourDerivedGraphicsClass : GraphicsClass
{
    public new void DrawRectangle() { }
}
```

Using the new keyword tells the compiler that your definition hides the definition that is contained in the base class. This is the default behavior.

### Override and Method Selection
When a method is named on a class, the C# compiler selects the best method to call if more than one method is compatible with the call, such as when there are two methods with the same name, and parameters that are compatible with the parameter passed. The following methods would be compatible:(当在类上命名方法时，如果有多个方法与调用兼容，例如有两个同名的方法，并且参数与传递的参数兼容，则c#编译器将选择最佳方法来调用。以下方法是兼容的:)
```C#
public class Derived : Base
{
    public override void DoWork(int param) { }
    public void DoWork(double param) { }
}
```
When DoWork is called on an instance of Derived, the C# compiler will first try to make the call compatible with the versions of DoWork declared originally on Derived. Override methods are not considered as declared on a class, they are new implementations of a method declared on a base class. Only if the C# compiler cannot match the method call to an original method on Derived, it will try to match the call to an overridden method with the same name and compatible parameters. For example:(当在Derived的实例上调用DoWork时，c#编译器将首先尝试使该调用与最初在Derived上声明的DoWork版本兼容。重写方法不被视为在类上声明的方法，它们是在基类上声明的方法的新实现。只有当c#编译器无法将方法调用匹配到派生上的原始方法时，它才会尝试将调用匹配到具有相同名称和兼容参数的重写方法。例如:)
> 即 有限选择原始方法
```C#
int val = 5;
Derived d = new Derived();
d.DoWork(val);  // Calls DoWork(double).
```
Because the variable val can be converted to a double implicitly, the C# compiler calls DoWork(double) instead of DoWork(int). There are two ways to avoid this. First, avoid declaring new methods with the same name as virtual methods. Second, you can instruct the C# compiler to call the virtual method by making it search the base class method list by casting the instance of Derived to Base. Because the method is virtual, the implementation of DoWork(int) on Derived will be called. For example:(因为变量val可以隐式地转换为double类型，c#编译器调用DoWork(double)而不是DoWork(int)。有两种方法可以避免这种情况。首先，避免声明与虚方法同名的新方法。其次，可以通过将派生类的实例强制转换为base，使其搜索基类方法列表，从而指示c#编译器调用虚拟方法。因为该方法是虚拟的，所以将调用派生上的DoWork(int)的实现。例如:)
```C#
((Base)d).DoWork(val);  // Calls DoWork(int) on Derived.
```

---

## 参考资料
1. [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance)