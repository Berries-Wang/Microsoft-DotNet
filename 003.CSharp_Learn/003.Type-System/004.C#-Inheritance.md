# Inheritance (继承)
Inheritance, together with encapsulation and polymorphism, is one of the three primary characteristics of object-oriented programming. Inheritance enables you to create new classes that reuse, extend, and modify the behavior defined in other classes. The class whose members are inherited is called the base class, and the class that inherits those members is called the derived class. A derived class can have only one direct base class. However, inheritance is transitive. If ClassC is derived from ClassB, and ClassB is derived from ClassA, ClassC inherits the members declared in ClassB and ClassA.(继承、封装和多态性是面向对象编程的三个主要特征之一。继承使您能够创建重用、扩展和修改在其他类中定义的行为的新类。继承其成员的类称为基类，继承这些成员的类称为派生类。派生类只能有一个直接基类。然而，继承是可传递的。如果ClassC从ClassB派生，而ClassB从ClassA派生，则ClassC继承在ClassB和ClassA中声明的成员。)

When you define a class to derive from another class, the derived class implicitly gains all the members of the base class, except for its constructors and finalizers. The derived class reuses the code in the base class without having to reimplement it. You can add more members in the derived class. The derived class extends the functionality of the base class.(当定义要从另一个类派生的类时，派生类隐式地获得基类的所有成员，但构造函数和终结器除外。派生类重用基类中的代码，而不必重新实现它。可以在派生类中添加更多成员。派生类扩展基类的功能。)

The following illustration shows a class WorkItem that represents an item of work in some business process. Like all classes, it derives from System.Object and inherits all its methods. WorkItem adds six members of its own. These members include a constructor, because constructors aren't inherited. Class ChangeRequest inherits from WorkItem and represents a particular kind of work item. ChangeRequest adds two more members to the members that it inherits from WorkItem and from Object. It must add its own constructor, and it also adds originalItemID. Property originalItemID enables the ChangeRequest instance to be associated with the original WorkItem to which the change request applies.(下面的插图显示了一个类WorkItem，它表示某个业务流程中的工作项。像所有类一样，它派生自System.Object 并继承其所有方法。WorkItem添加它自己的六个成员。这些成员包括一个构造函数，因为构造函数不能被继承。类ChangeRequest继承自WorkItem，并表示一种特定类型的工作项。ChangeRequest向它从WorkItem和Object继承的成员中添加了另外两个成员。它必须添加自己的构造函数，并且还添加了originalItemID。属性originalItemID使ChangeRequest实例能够与变更请求应用的原始工作项相关联。)
![class-inheritance-diagram.png](./IMGS/class-inheritance-diagram.png)

The following example shows how the class relationships demonstrated in the previous illustration are expressed in C#. The example also shows how WorkItem overrides the virtual method Object.ToString, and how the ChangeRequest class inherits the WorkItem implementation of the method. The first block defines the classes:(下面的示例展示了如何在c#中表达前面插图中演示的类关系。该示例还显示了WorkItem如何覆盖虚拟方法Object.ToString，以及ChangeRequest类如何继承该方法的WorkItem实现。第一个块定义了类:)
```C#
// WorkItem implicitly inherits from the Object class.
public class WorkItem
{
    // Static field currentID stores the job ID of the last WorkItem that
    // has been created.
    private static int currentID;

    //Properties.
    protected int ID { get; set; }
    protected string Title { get; set; }
    protected string Description { get; set; }
    protected TimeSpan jobLength { get; set; }

    // Default constructor. If a derived class does not invoke a base-
    // class constructor explicitly, the default constructor is called
    // implicitly.
    public WorkItem()
    {
        ID = 0;
        Title = "Default title";
        Description = "Default description.";
        jobLength = new TimeSpan();
    }

    // Instance constructor that has three parameters.
    public WorkItem(string title, string desc, TimeSpan joblen)
    {
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = joblen;
    }

    // Static constructor to initialize the static member, currentID. This
    // constructor is called one time, automatically, before any instance
    // of WorkItem or ChangeRequest is created, or currentID is referenced.
    static WorkItem() => currentID = 0;

    // currentID is a static field. It is incremented each time a new
    // instance of WorkItem is created.
    protected int GetNextID() => ++currentID;

    // Method Update enables you to update the title and job length of an
    // existing WorkItem object.
    public void Update(string title, TimeSpan joblen)
    {
        this.Title = title;
        this.jobLength = joblen;
    }

    // Virtual method override of the ToString method that is inherited
    // from System.Object.
    public override string ToString() =>
        $"{this.ID} - {this.Title}";
}

// ChangeRequest derives from WorkItem and adds a property (originalItemID)
// and two constructors.
public class ChangeRequest : WorkItem
{
    protected int originalItemID { get; set; }

    // Constructors. Because neither constructor calls a base-class
    // constructor explicitly, the default constructor in the base class
    // is called implicitly. The base class must contain a default
    // constructor.

    // Default constructor for the derived class.
    public ChangeRequest() { }

    // Instance constructor that has four parameters.
    public ChangeRequest(string title, string desc, TimeSpan jobLen,
                         int originalID)
    {
        // The following properties and the GetNexID method are inherited
        // from WorkItem.
        this.ID = GetNextID();
        this.Title = title;
        this.Description = desc;
        this.jobLength = jobLen;

        // Property originalItemID is a member of ChangeRequest, but not
        // of WorkItem.
        this.originalItemID = originalID;
    }
}
```

This next block shows how to use the base and derived classes:
```C#

// Create an instance of WorkItem by using the constructor in the
// base class that takes three arguments.
WorkItem item = new WorkItem("Fix Bugs",
                            "Fix all bugs in my code branch",
                            new TimeSpan(3, 4, 0, 0));

// Create an instance of ChangeRequest by using the constructor in
// the derived class that takes four arguments.
ChangeRequest change = new ChangeRequest("Change Base Class Design",
                                        "Add members to the class",
                                        new TimeSpan(4, 0, 0),
                                        1);

// Use the ToString method defined in WorkItem.
Console.WriteLine(item.ToString());

// Use the inherited Update method to change the title of the
// ChangeRequest object.
change.Update("Change the Design of the Base Class",
    new TimeSpan(4, 0, 0));

// ChangeRequest inherits WorkItem's override of ToString.
Console.WriteLine(change.ToString());
/* Output:
    1 - Fix Bugs
    2 - Change the Design of the Base Class
*/

```

## Abstract and virtual methods
When a base class declares a method as virtual, a derived class can override the method with its own implementation. If a base class declares a member as abstract, that method must be overridden in any non-abstract class that directly inherits from that class. If a derived class is itself abstract, it inherits abstract members without implementing them. Abstract and virtual members are the basis for polymorphism, which is the second primary characteristic of object-oriented programming. For more information, see Polymorphism.(当基类将方法声明为虚方法时，派生类可以用自己的实现覆盖该方法。如果基类将成员声明为抽象，则必须在直接继承该类的任何非抽象类中重写该方法。如果派生类本身是抽象的，则继承抽象成员而不实现它们。抽象成员和虚成员是多态的基础，多态是面向对象编程的第二个主要特征。有关更多信息，请参见多态性。)


## Abstract base classes
You can declare a class as abstract if you want to prevent direct instantiation by using the new operator. An abstract class can be used only if a new class is derived from it. An abstract class can contain one or more method signatures that themselves are declared as abstract. These signatures specify the parameters and return value but have no implementation (method body). An abstract class doesn't have to contain abstract members; however, if a class does contain an abstract member, the class itself must be declared as abstract. Derived classes that aren't abstract themselves must provide the implementation for any abstract methods from an abstract base class.(如果希望通过使用new操作符来防止直接实例化，可以将类声明为抽象类。抽象类只有在派生出新类时才能使用。抽象类可以包含一个或多个本身被声明为抽象的方法签名。这些签名指定参数和返回值，但没有实现(方法体)。抽象类不必包含抽象成员;但是，如果类确实包含抽象成员，则必须将类本身声明为抽象。本身不是抽象的派生类必须为来自抽象基类的任何抽象方法提供实现。)
```C#
   1. 抽象成员 是什么意思

```

## Interfaces
An interface is a reference type that defines a set of members. All classes and structs that implement that interface must implement that set of members. An interface may define a default implementation for any or all of these members. A class can implement multiple interfaces even though it can derive from only a single direct base class.(接口是定义一组成员的引用类型。所有实现该接口的类和结构都必须实现该成员集。接口可以为任何或所有这些成员定义默认实现。一个类可以实现多个接口，即使它只能从一个直接基类派生。)

Interfaces are used to define specific capabilities for classes that don't necessarily have an "is a" relationship. For example, the System.IEquatable\<T\> interface can be implemented by any class or struct to determine whether two objects of the type are equivalent (however the type defines equivalence). IEquatable\<T\> doesn't imply the same kind of "is a" relationship that exists between a base class and a derived class (for example, a Mammal is an Animal). For more information, see Interfaces.


## Preventing further derivation
A class can prevent other classes from inheriting from it, or from any of its members, by declaring itself or the member as sealed.(一个类可以通过将自己或成员声明为密封来防止其他类从它或它的任何成员继承。)
```C#
  
```

## Derived class hiding of base class members
A derived class can hide base class members by declaring members with the same name and signature. The new modifier can be used to explicitly indicate that the member isn't intended to be an override of the base member. The use of new isn't required, but a compiler warning will be generated if new isn't used. For more information, see Versioning with the Override and New Keywords and Knowing When to Use Override and New Keywords.(派生类可以通过声明具有相同名称和签名的成员来隐藏基类成员。新的修饰符可用于显式地指示成员不打算作为基成员的重写。不需要使用new，但如果不使用new，将生成一个编译器警告。有关详细信息，请参见使用覆盖和新关键字进行版本控制和了解何时使用覆盖和新关键字。)

---
## Knowing When to Use Override and New Keywords
In C#, a method in a derived class can have the same name as a method in the base class. You can specify how the methods interact by using the new and override keywords. The override modifier extends the base class virtual method, and the new modifier hides an accessible base class method. The difference is illustrated in the examples in this topic.(在c#中，派生类中的方法可以与基类中的方法具有相同的名称。您可以通过使用new和override关键字来指定方法的交互方式。重写修饰符扩展基类虚方法，新修饰符隐藏可访问的基类方法。本主题中的示例说明了它们之间的区别。)

In a console application, declare the following two classes, BaseClass and DerivedClass. DerivedClass inherits from BaseClass.
```C#
 
   class BaseClass  
   {  
       public void Method1()  
       {  
           Console.WriteLine("Base - Method1");  
       }  
   }  
     
   class DerivedClass : BaseClass  
   {  
       public void Method2()  
       {  
           Console.WriteLine("Derived - Method2");  
       }  
   }

```

In the Main method, declare variables bc, dc, and bcdc.
- bc is of type BaseClass, and its value is of type BaseClass.
- dc is of type DerivedClass, and its value is of type DerivedClass.
- bcdc is of type BaseClass, and its value is of type DerivedClass. This is the variable to pay attention to.

Because bc and bcdc have type BaseClass, they can only directly access Method1, unless you use casting. Variable dc can access both Method1 and Method2. These relationships are shown in the following code.

```C#
class Program  
{  
    static void Main(string[] args)  
    {  
        BaseClass bc = new BaseClass();  
        DerivedClass dc = new DerivedClass();  
        BaseClass bcdc = new DerivedClass();  
  
        bc.Method1();  
        dc.Method1();  
        dc.Method2();  
        bcdc.Method1();  
    }  
    // Output:  
    // Base - Method1  
    // Base - Method1  
    // Derived - Method2  
    // Base - Method1  
}
```

Next, add the following Method2 method to BaseClass. The signature of this method matches the signature of the Method2 method in DerivedClass.
```C#
  public void Method2()  
  {  
      Console.WriteLine("Base - Method2");  
  }
```

Because BaseClass now has a Method2 method, a second calling statement can be added for BaseClass variables bc and bcdc, as shown in the following code.
```C#
  bc.Method1();  
  bc.Method2();  
  dc.Method1();  
  dc.Method2();  
  bcdc.Method1();  
  bcdc.Method2();
```
When you build the project, you see that the addition of the Method2 method in BaseClass causes a warning. The warning says that the Method2 method in DerivedClass hides the Method2 method in BaseClass. You are advised to use the new keyword in the Method2 definition if you intend to cause that result. Alternatively, you could rename one of the Method2 methods to resolve the warning, but that is not always practical.
```C#
   // 当运行的时候，会输出一个警告：
   wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
   /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/Program_2.cs(38,17): warning CS0108: 'DerivedClass.Method2()' hides inherited member 'BaseClass.Method2()'. Use the new keyword if hiding was intended. [/home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/CSharp_Grammar_01.csproj]
   Base - Method1
   Base - Method2
   Base - Method1
   Derived - Method2 
   Base - Method1  
   Base - Method2 // 变量类型 BaseClass 变量值类型:DerivedClass
   // 即，提示使用new关键字去隐藏继承而来的BaseClass.Method2方法
   // 通过输出可以发现，对比dc.Method2(); ,此时方法的接收者绑定是根据变量的类型来的（类比: 004.OpenJDK(JVM)学习/011.执行与优化/003.Java与动态类型.md），而不是根据变量值的类型来绑定的
```

The new keyword preserves the relationships that produce that output, but it suppresses the warning. The variables that have type BaseClass continue to access the members of BaseClass, and the variable that has type DerivedClass continues to access members in DerivedClass first, and then to consider members inherited from BaseClass.(new关键字保留了产生该输出的关系，但它抑制了警告。具有BaseClass类型的变量继续访问BaseClass的成员，具有DerivedClass类型的变量继续首先访问DerivedClass中的成员，然后考虑从BaseClass继承的成员。)
> 即添加了new关键字，方法的接收者的绑定关系不会变

To suppress the warning, add the new modifier to the definition of Method2 in DerivedClass, as shown in the following code. The modifier can be added before or after public.(要抑制警告，将新的修饰符添加到DerivedClass中的Method2定义中，如下面的代码所示。修饰符可以在public之前或之后添加。)

```C#
  public new void Method2()  
  {  
      Console.WriteLine("Derived - Method2");  
  }

  // 再次执行，无警告
  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
  Base - Method1
  Base - Method2
  Base - Method1
  Derived - Method2
  Base - Method1
  Base - Method2
```

To contrast(对比) this behavior to the effects of using override, add the following method to DerivedClass. The override modifier can be added before or after public.
```C#
public override void Method1()  
{  
    Console.WriteLine("Derived - Method1");  
}
// 直接运行报错: 
wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
/home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/Program_2.cs(43,26): error CS0506: 'DerivedClass.Method1()': cannot override inherited member 'BaseClass.Method1()' because it is not marked virtual, abstract, or override [/home/wei/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01/CSharp_Grammar_01.csproj]

The build failed. Fix the build errors and run again.
wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ 
```

Add the virtual modifier to the definition of Method1 in BaseClass. The virtual modifier can be added before or after public.
```C#
   public virtual void Method1()  
  {  
      Console.WriteLine("Base - Method1");  
  }

  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
  Base - Method1
  Base - Method2
  Derived - Method1
  Derived - Method2
  Derived - Method1
  Base - Method2
  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ 
```

The use of the override modifier enables bcdc to access the Method1 method that is defined in DerivedClass. Typically, that is the desired behavior in inheritance hierarchies. You want objects that have values that are created from the derived class to use the methods that are defined in the derived class. You achieve that behavior by using override to extend the base class method.(override修饰符的使用使bcdc能够访问在DerivedClass中定义的Method1方法。通常，这是继承层次结构中所期望的行为。您希望具有从派生类创建的值的对象使用派生类中定义的方法。您可以通过使用override来扩展基类方法来实现该行为。)
> override 修饰符符合Java继承规范,new修饰符是根据变量类型来绑定方法接受者;override是在运行时根据变量值类型来绑定方法接收者的

### new override 修饰符完整示例
```C#
namespace Wei;

public class HelloMain
{
    static int Main(string[] args)
    {
        BaseClass bc = new BaseClass();
        DerivedClass dc = new DerivedClass();
        BaseClass bcdc = new DerivedClass();

        bc.Method1();
        bc.Method2();
        dc.Method1();
        dc.Method2();
        bcdc.Method1();
        bcdc.Method2();

        return 0;
    }

}

class BaseClass
{
    public virtual void Method1()
    {
        Console.WriteLine("Base - Method1");
    }

    public virtual void Method2()
    {
        Console.WriteLine("Base - Method2");
    }
}

class DerivedClass : BaseClass
{
    public new void Method2()
    {
        Console.WriteLine("Derived - Method2");
    }

    public override void Method1()
    {
        Console.WriteLine("Derived - Method1");
    }
}
  
  wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Debug/wei-sdk/dotnet  run 
  Base - Method1
  Base - Method2
  Derived - Method1
  Derived - Method2
  Derived - Method1
  Base - Method2
```

---


## Versioning with the Override and New Keywords


---

## 参考资料
1. [https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance)