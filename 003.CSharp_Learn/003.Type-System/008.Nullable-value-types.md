# Nullable value types
## 摘要
读完此文，需要知道：
1. 可空值,即 nullable value type , 如 int? 即表示可空值类型，这种类型是 System.Nullable\<T\>  的实例
2. 控制合并运算符: ??
3. 变量的类型判断: 可空值类型 、空值类型、基础类型

## 文档内容
A nullable value type T? represents all values of its underlying value type T and an additional null value. For example, you can assign any of the following three values to a bool? variable: true, false, or null. An underlying value type T cannot be a nullable value type itself.(一个可空值类型T?代表值类型T所有可能的值以及一个额外的空值(null),例如，你可以将如下三个 true 、 false 或 null 中任意一个值赋值给bool?类型的变量，基础类型值类型T本身不能为空值类型)

Any nullable value type is an instance of the generic System.Nullable\<T\> structure. You can refer to a nullable value type with an underlying type T in any of the following interchangeable<sup>可互换的；可交换的；可交替的</sup> forms: Nullable\<T\> or T?. (任何一个可控制类型是泛型System.Nullable\<T\>结构的一个实例，可以使用如下可互换的形式：Nullable\<T\> 或 T? 来引用基础类型T的可空值类型。)

You typically<sup>典型地，有代表性地；一般，通常；一向如此地，不出所料地</sup> use a nullable value type when you need to represent the undefined value of an underlying value type. For example, a Boolean, or bool, variable can only be either true or false. However, in some applications a variable value can be undefined or missing. For example, a database field may contain true or false, or it may contain no value at all, that is, NULL. You can use the bool? type in that scenario<sup>设想，可能发生的情况 ；</sup>.(在你需要表示一个未定义值的基础值类型的时候你一般可以使用可空值类型，例如，Boolean 或 bool变量只能为true 或 false，然后，在一些应用中，一个变量值可能或未定义或缺失。例如，数据库字段或许包含ture或false，或者他根本不就没有值，那种情况下，值为NULL,在那种情况下你可以使用bool?类型)

### Declaration and assignment
As a value type is implicitly<sup>含蓄地，暗中地；绝对地</sup> convertible to the corresponding nullable value type, you can assign a value to a variable of a nullable value type as you would do that for its underlying value type. You can also assign the null value. For example:（由于值类型可以隐式转换为对应的可空值类型，你可以像为变量的基础类型赋值一样将值赋给可空值类型的变量，你也可以执行null值，例如:）
```C#
   {
		System.Console.WriteLine("Hello World");
		int? n = null;
		System.Console.WriteLine(n);

		double? pi = 3.14;
		char? letter = 'a';

		System.Console.WriteLine(letter.HasValue); // True

		int m2 = 10;
		int? m = m2;

		bool? flag = null;
		System.Console.WriteLine(flag.HasValue); // False

		// An array of a nullable value type:
		int?[] arr = new int?[10];
	}
```

The default value of a nullable value type represents null, that is, it's an instance whose Nullable\<T\>.HasValue property returns false.(可空值类型的默认值是null，也就是说，他是有一个返回false的Nullable\<T\>.HasValue属性的实例)

### Examination of an instance of a nullable value type
You can use the is operator with a type pattern to both examine an instance of a nullable value type for null and retrieve a value of an underlying type:(你可以使用is操作符搭配类型模式来同时判断可空类型值实例是否为null以及接收基础类型的值)
```C#
   {
			int? a = 42;
			if (a is int valueOfA)
			{
				Console.WriteLine($"a is {valueOfA}");
			}
			else
			{
				Console.WriteLine("a does not have a value");
			}
			//输出:  
			// a is 42
	}
```

You always can use the following read-only properties to examine and get a value of a nullable value type variable:
- Nullable\<T\>.HasValue indicates whether an instance of a nullable value type has a value of its underlying type.
- Nullable\<T\>.Value gets the value of an underlying type if HasValue is true. If HasValue is false, the Value property throws an InvalidOperationException.

The following example uses the HasValue property to test whether the variable contains a value before displaying it:
```C#
        {
			int? b = 10;
			if (b.HasValue)
			{
				Console.WriteLine($"b is {b.Value}");
			}
			else
			{
				Console.WriteLine("b does not have a value");
			}
			// 输出:
			// b is 10
		}
```

You can also compare a variable of a nullable value type with null instead of using the HasValue property, as the following example shows:
```C#
		{
			int? c = 7;
			if (c != null)
			{
				Console.WriteLine($"c is {c.Value}");
			}
			else
			{
				Console.WriteLine("c does not have a value");
			}
			// Output:
			// c is 7
		}
```

### Conversion from a nullable value type to an underlying type
> 从可空值类型到基础类型的转换

If you want to assign a value of a nullable value type to a non-nullable value type variable, you might need to specify the value to be assigned in place of null. Use the null-coalescing<sup>空值合并运算符</sup> operator ?? to do that (you can also use the Nullable\<T\>.GetValueOrDefault(T) method for the same purpose):(如果你想将可空值类型的值赋值给一个不可空值类型的变量，可能需要指定要赋值的值来代替null。可以使用??空值合并运算符来实现（你也可以使用）Nullable\<T\>.GetValueOrDefault(T) 方法来实现同样的目的)
```C#
        {
			int? a = 28;
			int b = a ?? -1; // 空值合并运算符
			Console.WriteLine($"b is {b}");  // output: b is 28

			int? c = null;
			int d = c ?? -1;
			Console.WriteLine($"d is {d}");  // output: d is -1
		}
```

If you want to use the default value of the underlying value type in place of null, use the Nullable\<T\>.GetValueOrDefault() method.（如果你想使用基础类型默认值来代替null，使用Nullable\<T\>.GetValueOrDefault()方法）

You can also explicitly cast a nullable value type to a non-nullable type, as the following example shows:(还可以显式地将可空值类型转换为非空类型，如下面的例子所示:)
```C#
        {
			int? n = null;

			// int m1 = n;    // Doesn't compile 即 无法编译
			int n2 = (int)n; // Compiles, but throws an exception if n is null //  Unhandled exception. System.InvalidOperationException: Nullable object must have a value.
		}
```

### Lifted operators
> 提升操作符: 在 C# 中，“Lifted operators”（提升操作符）指的是针对值类型（如结构体）进行的一种特殊形式的操作符重载。这些运算符的设计目的是为了支持对可空类型（Nullable<T>）的操作。
>> 在 C# 中，值类型（如 int、double 等）不能直接为 null。然而，通过 Nullable<T> 类型，可以让值类型支持 null 值。当你对这些可空类型进行运算时，就会涉及提升操作符。


The predefined unary and binary operators or any overloaded operators that are supported by a value type T are also supported by the corresponding nullable value type T?. These operators, also known as lifted operators, produce null if one or both operands are null; otherwise, the operator uses the contained values of its operands to calculate the result. For example:（预定义的一元和二元操作符或值类型T支持的任何重载操作符，相应的可空值类型T也支持。这些运算符也称为提升运算符(operator)，如果一个或两个操作数都是null，则返回null;否则，运算符使用包含的操作数的值来计算结果。例如:）
```C#
    int? a = 5;
    int? b = null;
    
    int? sum = a + b; // sum 将会是 null，因为 b 是 null
    
    int? c = 10;
    int? total = a + c; // total 将是 15，因为 a 和 c 都不是 null
```

For the comparison operators <, >, <=, and >=, if one or both operands are null, the result is false; otherwise, the contained values of operands are compared. Do not assume that because a particular comparison (for example, <=) returns false, the opposite comparison (>) returns true. The following example shows that 10 is (对于比较运算符<, >, <=, 以及 >= , 如果一个或所有的操作数都是null，那么结果就是false，否则，比较包含的操作数的值，不要认为特定的比较(<=)返回false，则相反的操作(>)就返回true <sup>即，比较运算符的值可能为false，true，null</sup>，如下例子，10)
- neither greater than or equal to null ： 既不大于等于null
- nor less than null : 也不小于null

```C#
        {
			int? a = 10;
			Console.WriteLine($"{a} >= null is {a >= null}"); // 10 >= null is False
			Console.WriteLine($"{a} < null is {a < null}"); // 10 < null is False
			Console.WriteLine($"{a} == null is {a == null}"); // 10 == null is False

			int? b = null;
			int? c = null;
			Console.WriteLine($"null >= null is {b >= c}"); // null >= null is False
			Console.WriteLine($"null == null is {b == c}"); // null == null is True
		}
```

For the equality operator ==, if both operands are null, the result is true, if only one of the operands is null, the result is false; otherwise, the contained values of operands are compared.

For the inequality operator !=, if both operands are null, the result is false, if only one of the operands is null, the result is true; otherwise, the contained values of operands are compared.

If there exists a user-defined conversion between two value types, the same conversion can also be used between the corresponding nullable value types


### Boxing and unboxing
An instance of a nullable value type T? is boxed as follows:
- If HasValue returns false, the null reference is produced.
- If HasValue returns true, the corresponding value of the underlying value type T is boxed, not the instance of Nullable\<T\>.

You can unbox a boxed value of a value type T to the corresponding nullable value type T?, as the following example shows:
```C#
    int a = 41;
    object aBoxed = a;
    int? aNullable = (int?)aBoxed;
    Console.WriteLine($"Value of aNullable: {aNullable}");
    
    object aNullableBoxed = aNullable;
    if (aNullableBoxed is int valueOfA)
    {
        Console.WriteLine($"aNullableBoxed is boxed int: {valueOfA}");
    }
    // Output:
    // Value of aNullable: 41
    // aNullableBoxed is boxed int: 41
```

### How to identify a nullable value type
> 使用Nullable.GetUnderlyingType 或 typeof

The following example shows how to determine whether a System.Type instance represents a constructed nullable value type, that is, the System.Nullable\<T\> type with a specified type parameter T:
```C#
    Console.WriteLine($"int? is {(IsNullable(typeof(int?)) ? "nullable" : "non nullable")} value type");
    Console.WriteLine($"int is {(IsNullable(typeof(int)) ? "nullable" : "non-nullable")} value type");
    
    bool IsNullable(Type type) => Nullable.GetUnderlyingType(type) != null;
    
    // Output:
    // int? is nullable value type
    // int is non-nullable value type
```

As the example shows, you use the typeof operator to create a System.Type instance.

If you want to determine whether an instance is of a nullable value type, don't use the Object.GetType method to get a Type instance to be tested with the preceding code. When you call the Object.GetType method on an instance of a nullable value type, the instance is boxed to Object. As boxing of a non-null instance of a nullable value type is equivalent to boxing of a value of the underlying type, GetType returns a Type instance that represents the underlying type of a nullable value type:(如果你想判断一个实例是否是可空值类型，不能使用 Object.GetType方法。当你使用Object.GetType方法时，这个实例是被包装成了一个对象。非空可空值类型实例装箱等价于基础类型进行装箱，GetType返回基础类型)

```C#
    {
		int? a = 17;
		Type typeOfA = a.GetType();
		Console.WriteLine(typeOfA.FullName); // System.Int32	
	}
```

Also, don't use the is operator to determine whether an instance is of a nullable value type. As the following example shows, you cannot distinguish types of a nullable value type instance and its underlying type instance with the is operator:(此外，不要使用is操作符来确定实例是否为可空值类型。如下面的例子所示，你不能用is操作符区分可空值类型实例和其基础类型实例的类型)

```C#
        {
			int? a = 14;
			if (a is int)
			{
				Console.WriteLine("int? instance is compatible with int");
			}

			int b = 17;
			if (b is int?)
			{
				Console.WriteLine("int instance is compatible with int?");
			}

			//➜  nullable_type dotnet run 
			// /Users/wang/WorkSpace/WangSpace/test/nullable_type/Program.cs(16,8): warning CS0183: 给定表达式始终为所提供的(“int?”)类型 [/Users/wang/WorkSpace/WangSpace/test/nullable_type/nullable_type.csproj]
			// int? instance is compatible with int
			// int instance is compatible with int?
		}
```

Instead use the Nullable.GetUnderlyingType from the first example and typeof operator to check if an instance is of a nullable value type. (相反，请使用Nullable.GetUnderlyingType 和typeof操作符检查实例是否为可空值类型。)


---

## 附录
1. underlying value type： 基础值类型

--- 

## 参考文档
1. [Nullable value types (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types)
