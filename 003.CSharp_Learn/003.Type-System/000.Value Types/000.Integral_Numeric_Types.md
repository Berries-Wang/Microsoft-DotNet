# Integral numeric types
## 简要
1. 数值类型有哪些
2. 本地大小类型: native-sized integers
3. 类型转换: 隐式 and 显式

## Characteristics of the integral types
C# supports the following predefined integral types:
| C# type/keyword | Range                                                   | Size                              | .NET type      |
|-----------------|---------------------------------------------------------|-----------------------------------|----------------|
| sbyte           | -128 to 127                                             | Signed 8-bit integer              | System.SByte   |
| int             | -2,147,483,648 to 2,147,483,647                         | Signed 32-bit integer             | System.Int32   |
| short           | -32,768 to 32,767                                       | Signed 16-bit integer             | System.Int16   |
| long            | -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 | Signed 64-bit integer             | System.Int64   |
| ulong           | 0 to 18,446,744,073,709,551,615                         | Unsigned 64-bit integer           | System.UInt64  |
| byte            | 0 to 255                                                | Unsigned 8-bit integer            | System.Byte    |
| uint            | 0 to 4,294,967,295                                      | Unsigned 32-bit integer           | System.UInt32  |
| ushort          | 0 to 65,535                                             | Unsigned 16-bit integer           | System.UInt16  |
| nint            | Depends on platform (computed at runtime)               | Signed 32-bit or 64-bit integer   | System.IntPtr  |
| nuint           | Depends on platform (computed at runtime)               | Unsigned 32-bit or 64-bit integer | System.UIntPtr |

In all of the table rows except the last two, each C# type keyword from the leftmost column is an alias for the corresponding .NET type. The keyword and .NET type name are interchangeable. For example, the following declarations declare variables of the same type:(在除了最后两行之外的所有表行中，最左边列的每个c# type关键字都是对应的 .NET type的别名。关键字和.NET type名称可以互换。例如，下面的声明声明了相同类型的变量:)
```c#
   int a = 123;
   System.Int32 b = 123;
```

The nint and nuint types in the last two rows of the table are native-sized integers. You can use the nint and nuint contextual keywords to define native-sized integers. These are 32-bit integers when running in a 32-bit process, or 64-bit integers when running in a 64-bit process. They can be used for interop scenarios, low-level libraries, and to optimize performance in scenarios where integer math is used extensively.(表的最后两行中的nint和nuint类型是原生大小的整数。你可以使用上下文关键字nint和nuint来定义大小为本机的整数。在32位程序上运行时，它们是32位整数;在64位程序中运行时，它们是64位整数。它们可以用于互操作场景、底层库，并在广泛使用整数数学的场景中优化性能。)

The native-sized integer types are represented internally as the .NET types System.IntPtr and System.UIntPtr. Starting in C# 11, the nint and nuint types are aliases for the underlying types.（原生大小的整数类型在内部表示为.NET类型系统。和System.UIntPtr。从c# 11开始，nint和nuint类型是底层类型的别名。）

The default value of each integral type is zero, 0.
> 正式类型默认值

Each of the integral types has MinValue and MaxValue properties that provide the minimum and maximum value of that type. These properties are compile-time constants except for the case of the native-sized types (nint and nuint). The MinValue and MaxValue properties are calculated at runtime for native-sized types. The sizes of those types depend on the process settings.（每个整数类型都有MinValue和MaxValue属性，分别表示该类型的最小值和最大值。这些属性都是编译时常量，原生大小的类型(nint和nuint)除外。对于原生大小的类型，MinValue和MaxValue属性是在运行时计算的。这些类型的大小取决于程序设置。）

Use the System.Numerics.BigInteger structure to represent a signed integer with no upper or lower bounds.（使用System.Numerics.BigInteger结构来表示没有上限和下限的有符号整数。）
> 没有上限 和 下限的有符号整形

---

## Integer literals (整形常量)
Integer literals can be
- decimal: without any prefix
- hexadecimal: with the 0x or 0X prefix
- binary: with the 0b or 0B prefix

代码示例如下:
```c#
var decimalLiteral = 42;
var hexLiteral = 0x2A;
var binaryLiteral = 0b_0010_1010;
```
The preceding example also shows the use of _ as a digit separator. You can use the digit separator with all kinds of numeric literals.(上面的例子还展示了如何使用_作为数字分隔符。可以对各种数字字面量使用数字分隔符。)

The type of an integer literal is determined by its suffix as follows:(整数字面量的类型由后缀表示)
1. If the literal has no suffix, its type is the first of the following types in which its value can be represented: int, uint, long, ulong.（如果字面量没有后缀，它的类型是其值可以表示的下列类型中的第一种:int、uint、long、ulong。）
2. If the literal is suffixed by U or u, its type is the first of the following types in which its value can be represented: uint, ulong.
3. If the literal is suffixed by L or l, its type is the first of the following types in which its value can be represented: long, ulong.
4. If the literal is suffixed by UL, Ul, uL, ul, LU, Lu, lU, or lu, its type is ulong.
5. 后缀是啥意思?
   ```C#
      var a = 9999UL; // 即表示字面量的类型
      Console.WriteLine($"a-->{a}");
   ```
If the value represented by an integer literal exceeds(超过) UInt64. MaxValue, a compiler error CS1021 occurs.

If the determined type of an integer literal is int and the value represented by the literal is within the range of the destination type, the value can be implicitly converted to sbyte, byte, short, ushort, uint, ulong, nint or nuint:（如果确定的整型字面量的类型是int，并且由这个字面量表示的值在目标类型的范围内，那么这个值可以隐式转换为sbyte、byte、short、ushort、uint、ulong、int或nuint:）
```C#
   byte a = 17;
   // 如果字面量不在类型范围内,则会报错
   byte b = 300;   // CS0031: Constant value '300' cannot be converted to a 'byte'
```

You can also use a cast to convert the value represented by an integer literal to the type other than the determined type of the literal:(还可以使用校正将整数字面量表示的值转换为其他类型:)
```C#
var signedByte = (sbyte)42;
var longVariable = (long)42;
```

## Conversions (转换)
You can convert any integral numeric type to any other integral numeric type. If the destination type can store all values of the source type, the conversion is implicit. Otherwise, you need to use a cast expression to perform an explicit conversion.(可以将任何整数类型转换为任何其他整数类型。如果目标类型可以存储源类型的所有值，则转换是隐式的。否则，需要使用校正表达式来执行显式转换)

## Native sized integers
Native sized integer types have special behavior because the storage is determined by the natural integer size on the target machine.(原生大小的整数类型具有特殊的行为，因为存储空间是由目标计算机上的自然整数大小决定的。)

- To get the size of a native-sized integer at run time, you can use sizeof(). However, the code must be compiled in an unsafe context. For example:(要在运行时获得原生整数的大小，可以使用sizeof()。但是，代码必须在不安全的上下文中编译。例如:)
   ```C#
       Console.WriteLine($"size of nint = {sizeof(nint)}");
       Console.WriteLine($"size of nuint = {sizeof(nuint)}");
       
       // output when run in a 64-bit process
       //size of nint = 8
       //size of nuint = 8
       
       // output when run in a 32-bit process
       //size of nint = 4
       //size of nuint = 4
   ```
   You can also get the equivalent value from the static IntPtr.Size and UIntPtr.Size properties.

- To get the minimum and maximum values of native-sized integers at run time, use MinValue and MaxValue as static properties with the nint and nuint keywords, as in the following example:(要在运行时获得原生整数的最小值和最大值，可以使用MinValue和MaxValue作为静态属性，同时使用关键字nint和nuint，如下面的例子所示。)
   ```C#
      Console.WriteLine($"nint.MinValue = {nint.MinValue}");
      Console.WriteLine($"nint.MaxValue = {nint.MaxValue}");
      Console.WriteLine($"nuint.MinValue = {nuint.MinValue}");
      Console.WriteLine($"nuint.MaxValue = {nuint.MaxValue}");
      
      // output when run in a 64-bit process
      //nint.MinValue = -9223372036854775808
      //nint.MaxValue = 9223372036854775807
      //nuint.MinValue = 0
      //nuint.MaxValue = 18446744073709551615
      
      // output when run in a 32-bit process
      //nint.MinValue = -2147483648
      //nint.MaxValue = 2147483647
      //nuint.MinValue = 0
      //nuint.MaxValue = 4294967295
   ```
- You can use constant values in the following ranges:
  + For nint: Int32.MinValue to Int32.MaxValue.
  + For nuint: UInt32.MinValue to UInt32.MaxValue.
- The compiler provides implicit(隐式的) and explicit(显式的) conversions to other numeric types. For more information, see [Built-in numeric conversions](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/numeric-conversions).
- There's no direct syntax for native-sized integer literals. There's no suffix to indicate that a literal is a native-sized integer, such as L to indicate a long. You can use implicit or explicit casts of other integer values instead. For example:(原生大小的整数字面量没有直接的语法。没有后缀来表示字面量是原生大小的整数，比如用L表示长整数。您可以使用其他整数值的隐式或显式类型转换。例如:)
  ```C#
    nint a = 42
    nint a = (nint)42;
  ```

## 参考资料
1. [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/integral-numeric-types)












