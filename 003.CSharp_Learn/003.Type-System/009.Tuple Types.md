# Tuple types 
## 简要
1. 轻量级数据结构
2. 元组类型匹配根据类型和参数个数，不根据字段名称来匹配

## 文档
The tuples feature provides concise syntax to group multiple data elements in a lightweight data structure. The following example shows how you can declare a tuple variable, initialize it, and access its data members:(元组特性为在轻量级数据结构中分组多个数据元素提供了简洁的语法。下面的例子展示了如何声明、初始化元组变量并访问其数据成员:)

```C#
        {
			(double, int) t1 = (4.5, 3);
			Console.WriteLine($"Tuple with elements {t1.Item1} and {t1.Item2}."); // Tuple with elements 4.5 and 3.

			(double Sum, int Count) t2 = (4.5, 3);
			Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}."); // Sum of 3 elements is 4.5.
		}  
```

As the preceding example shows, to define a tuple type, you specify types of all its data members and, optionally, the field names. You can't define methods in a tuple type, but you can use the methods provided by .NET, as the following example shows:(如前面的例子所示，要定义元组类型，需要指定其所有数据成员的类型，还可以指定字段名称。你不能在元组类型中定义方法，但可以使用.NET提供的方法，如下面的例子所示:)

```C#
        {
			(double, int) t = (4.5, 3);
			Console.WriteLine(t.ToString()); // (4.5, 3)
			Console.WriteLine($"Hash code of {t} is {t.GetHashCode()}."); // Hash code of (4.5, 3) is -2044569258.
		}
```


Tuple types are value types; tuple elements are public fields. That makes tuples mutable value types.(元组类型是值类型;元组元素是公共字段。这使得元组成为可变的值类型。)

You can define tuples with an arbitrary large number of elements:
```C#
var t =
(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12, 13, 14, 15, 16, 17, 18,
19, 20, 21, 22, 23, 24, 25, 26);
Console.WriteLine(t.Item26);  // output: 26
```

### Use cases of tuples
One of the most common use cases of tuples is as a method return type. That is, instead of defining out method parameters, you can group method results in a tuple return type, as the following example shows:(元组最常见的用例之一是作为方法返回类型。也就是说，你可以用tuple返回类型来分组方法结果，而不是定义方法返回参数，如下面的例子所示:)
```C#
public class TupleTypeStu
{

	public static void Main(string[] args)
	{
		{

			int[] xs = new int[] { 4, 7, 9 };
			var limits = FindMinMax(xs);
			Console.WriteLine($"Limits of [{string.Join(" ", xs)}] are {limits.min} and {limits.max}");
			// Output:
			// Limits of [4 7 9] are 4 and 9

			int[] ys = new int[] { -9, 0, 67, 100 };
			var (minimum, maximum) = FindMinMax(ys);
			Console.WriteLine($"Limits of [{string.Join(" ", ys)}] are {minimum} and {maximum}");
			// Output:
			// Limits of [-9 0 67 100] are -9 and 100

		}
	}

	public static (int min, int max) FindMinMax(int[] input)
	{
		if (input is null || input.Length == 0)
		{
			throw new ArgumentException("Cannot find minimum and maximum of a null or empty array.");
		}

		// Initialize min to MaxValue so every value in the input
		// is less than this initial value.
		var min = int.MaxValue;
		// Initialize max to MinValue so every value in the input
		// is greater than this initial value.
		var max = int.MinValue;
		foreach (var i in input)
		{
			if (i < min)
			{
				min = i;
			}
			if (i > max)
			{
				max = i;
			}
		}
		return (min, max);
	}

}
```

As the preceding example shows, you can work with the returned tuple instance directly or deconstruct(解构) it in separate variables.(如前面的例子所示，你可以直接使用返回的元组实例，也可以将其分解为单独的变量。)

You can also use tuple types instead of anonymous types; for example, in LINQ queries. For more information, see Choosing between anonymous and tuple types.

Typically, you use tuples to group loosely related data elements. In public APIs, consider defining a class or a structure type.(通常，使用元组对松散相关的数据元素进行分组。在公共api中，考虑定义一个类或结构类型。)


### Tuple field names
You explicitly specify tuple fields names in a tuple initialization expression or in the definition of a tuple type, as the following example shows:(你可以在元组初始化表达式或元组类型的定义中显式指定元组字段名称，如下面的例子所示:)
```C#
var t = (Sum: 4.5, Count: 3);
Console.WriteLine($"Sum of {t.Count} elements is {t.Sum}.");

(double Sum, int Count) d = (4.5, 3);
Console.WriteLine($"Sum of {d.Count} elements is {d.Sum}.");
```

If you don't specify a field name, it may be inferred from the name of the corresponding variable in a tuple initialization expression, as the following example shows:(如果没有指定字段名，则可以从元组初始化表达式中对应变量的名称推断出字段名，如下面的例子所示:)
```C#
        {

			var sum = 4.5;
			var count = 3;
			var t = (sum, count);
			Console.WriteLine($"Sum of {t.count} elements is {t.sum}."); // Sum of 3 elements is 4.5.
			Console.WriteLine($"{t.GetType()}"); // System.ValueTuple`2[System.Double,System.Int32]
		}
```

That's called tuple projection initializers. The name of a variable isn't projected onto a tuple field name in the following cases:(这称为元组投影初始化。在以下情况下，变量名不会映射到元组字段名。)
- The candidate name is a member name of a tuple type, for example, Item3, ToString, or Rest.
- The candidate name is a duplicate of another tuple field name, either explicit or implicit.

In the preceding cases, you either explicitly specify the name of a field or access a field by its default name.(在上述情况中，要么显式指定字段的名称，要么通过字段的默认名称访问字段。)

The default names of tuple fields are Item1, Item2, Item3 and so on. You can always use the default name of a field, even when a field name is specified explicitly or inferred, as the following example shows:（元组字段的默认名称是Item1、Item2、Item3等。你总是可以使用字段的默认名称，即使字段名称是显式指定或推断出来的，如下面的例子所示:）
```C#
        {
			var a = 1;
			var t = (a, b: 2, 3);
			Console.WriteLine($"The 1st element is {t.Item1} (same as {t.a})."); // The 1st element is 1 (same as 1).
			Console.WriteLine($"The 2nd element is {t.Item2} (same as {t.b})."); // The 2nd element is 2 (same as 2).
			Console.WriteLine($"The 3rd element is {t.Item3}."); // The 3rd element is 3.
		}
```

Tuple assignment and tuple equality comparisons don't take field names into account.(元组赋值和元组相等比较不考虑字段名。)

At compile time, the compiler replaces non-default field names with the corresponding default names. As a result, explicitly specified or inferred field names aren't available at run time.(编译时，编译器会用对应的默认字段名替换非默认字段名。因此，显式指定或推断的字段名在运行时不可用。)
> 编译时，使用默认的字段名,不会使用自定义的字段名

Beginning with C# 12, you can specify an alias for a tuple type with a using directive. The following example adds a global using alias for a tuple type with two integer values for an allowed Min and Max value:(从c# 12开始，你可以使用using指令为**元组类型**指定别名。下面的例子使用别名为元组类型添加一个全局变量，其中允许的Min和Max为两个整数值:)
```C#
     global using BandPass = (int Min, int Max);   
```

After declaring the alias, you can use the BandPass name as an alias for that tuple type:
```C#
global using BandPass = (int Min, int Max);

namespace Tuple_type;

public class TupleTypeStu
{
	public static void Main(string[] args)
	{
		{
			BandPass bracket = (40, 100);
			Console.WriteLine($"The bandpass filter is {bracket.Min} to {bracket.Max}"); // The bandpass filter is 40 to 100
		}
	}
}
```

An alias doesn't introduce a new type, but only creates a synonym for an existing type. You can deconstruct a tuple declared with the BandPass alias the same as you can with its underlying tuple type:(别名不会引入新类型，而只是为现有类型创建一个同义词。你可以解析使用BandPass别名声明的元组，就像解析其底层元组类型一样:)
```C#
global using BandPass = (int Min, int Max);

namespace Tuple_type;

public class TupleTypeStu
{
    public st
    atic void Main(string[] args)
    {
        {
            BandPass bracket = (40, 100);
            Console.WriteLine($"The bandpass filter is {bracket.Min} to {bracket.Max}"); // The bandpass filter is 40 to 100

            (int a, int b) = bracket;
            Console.WriteLine($"The bracket is {a} to {b}"); // The bracket is 40 to 100
        }
    }
}
```

As with tuple assignment or deconstruction, the tuple member names don't need to match; the types do.（与元组赋值和解构一样，元组成员名称不需要匹配，根据类型匹配）

Similarly, a second alias with the same arity and member types can be used interchangeably with the original alias. You could declare a second alias:（类似地，具有相同的arity和成员类型的第二个别名可以与原始别名互换使用。你可以声明第二个别名）
```C#
   using Range = (int Minimum, int Maximum);
```

You can assign a Range tuple to a BandPass tuple. As with all tuple assignment, the field names need not match, only the types and the arity(参数数量).(你可以将一个范围元组分配给一个带通元组。与所有的元组赋值一样，字段名不需要匹配，只需要匹配类型和参数数量即可。)
```C#
global using BandPass = (int Min, int Max);

using Range = (int Minimum, int Maximum);

using Range_3 = (int Minimum, int middle, int Maximum);

namespace Tuple_type;

public class TupleTypeStu
{
    public static void Main(string[] args)
    {
        {

            BandPass bracket = (40, 100);
            Console.WriteLine($"The bandpass filter is {bracket.Min} to {bracket.Max}"); // The bandpass filter is 40 to 100

            (int a, int b) = bracket;
            Console.WriteLine($"The bracket is {a} to {b}"); // The bracket is 40 to 100

            Range r = bracket;
            Console.WriteLine($"The range is {r.Minimum} to {r.Maximum}"); // The range is 40 to 100

           // Range_3 range_3 = bracket; // 异常: error CS0029: 无法将类型“(int Min, int Max)”隐式转换为“(int Minimum, int middle, int Maximum)”
        }
    }
}

```

An alias for a tuple type provides more semantic information when you use tuples. It doesn't introduce a new type. To provide type safety, you should declare a positional record instead.(使用元组时，元组类型的别名可以提供更多语义信息。它没有引入新类型。为了提供类型安全，你应该声明一个位置record。)

### Tuple assignment and deconstruction
C# supports assignment between tuple types that satisfy both of the following conditions:(C#支持元组类型之间的赋值，满足以下两个条件:)
- both tuple types have the same number of elements.(元组需要有相同数量的元素)
- for each tuple position, the type of the right-hand tuple element is the same as or implicitly(隐式转换) convertible(转换) to the type of the corresponding left-hand tuple element.(对于每个元组的的位置，右值类型必须和对应位置左值类型相同或者可以隐式转换为对应位置左值类型)

Tuple element values are assigned following the order of tuple elements. The names of tuple fields are ignored and not assigned, as the following example shows:（元组元素的值按照元组元素的顺序赋值。元组字段的名称会被忽略，也不会被赋值，如下面的例子所示:）
```C#
        {
            (int, double) t1 = (17, 3.14);
            (double First, double Second) t2 = (0.0, 1.0);
            t2 = t1;
            Console.WriteLine($"{nameof(t2)}: {t2.First} and {t2.Second}"); // t2: 17 and 3.14


            (double A, double B) t3 = (2.0, 3.0);
            t3 = t2;
            Console.WriteLine($"{nameof(t3)}: {t3.A} and {t3.B}"); //t3: 17 and 3.14
        }
```



## 参考资料
1. [Tuple types (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)
