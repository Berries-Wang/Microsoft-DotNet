# Tuple types 
## 简要
1. 轻量级数据结构
2. 元组类型匹配根据类型和参数个数，不根据字段名称来匹配

## 文档
The tuples feature provides concise syntax to group multiple data elements in a lightweight data structure. The following example shows how you can declare a tuple variable, initialize it, and access its data members:(元组特性为在轻量级数据结构中分组多个数据元素提供了简洁的语法。下面的例子展示了如何声明、初始化元组变量并访问其数据成员:)

```C#
        {
			(double, int) t1 = (4.5, 3);
			Console.WriteLine($"Tuple with elements {t1.Item1} and {t1.Item2}."); // Tuple with elements 4.5 and 3.

			(double Sum, int Count) t2 = (4.5, 3);
			Console.WriteLine($"Sum of {t2.Count} elements is {t2.Sum}."); // Sum of 3 elements is 4.5.
		}  
```

As the preceding example shows, to define a tuple type, you specify types of all its data members and, optionally, the field names. You can't define methods in a tuple type, but you can use the methods provided by .NET, as the following example shows:(如前面的例子所示，要定义元组类型，需要指定其所有数据成员的类型，还可以指定字段名称。你不能在元组类型中定义方法，但可以使用.NET提供的方法，如下面的例子所示:)

```C#
        {
			(double, int) t = (4.5, 3);
			Console.WriteLine(t.ToString()); // (4.5, 3)
			Console.WriteLine($"Hash code of {t} is {t.GetHashCode()}."); // Hash code of (4.5, 3) is -2044569258.
		}
```


Tuple types are value types; tuple elements are public fields. That makes tuples mutable value types.(元组类型是值类型;元组元素是公共字段。这使得元组成为可变的值类型。)

You can define tuples with an arbitrary large number of elements:
```C#
var t =
(1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
11, 12, 13, 14, 15, 16, 17, 18,
19, 20, 21, 22, 23, 24, 25, 26);
Console.WriteLine(t.Item26);  // output: 26
```

### Use cases of tuples
One of the most common use cases of tuples is as a method return type. That is, instead of defining out method parameters, you can group method results in a tuple return type, as the following example shows:(元组最常见的用例之一是作为方法返回类型。也就是说，你可以用tuple返回类型来分组方法结果，而不是定义方法返回参数，如下面的例子所示:)
```C#
public class TupleTypeStu
{

	public static void Main(string[] args)
	{
		{

			int[] xs = new int[] { 4, 7, 9 };
			var limits = FindMinMax(xs);
			Console.WriteLine($"Limits of [{string.Join(" ", xs)}] are {limits.min} and {limits.max}");
			// Output:
			// Limits of [4 7 9] are 4 and 9

			int[] ys = new int[] { -9, 0, 67, 100 };
			var (minimum, maximum) = FindMinMax(ys);
			Console.WriteLine($"Limits of [{string.Join(" ", ys)}] are {minimum} and {maximum}");
			// Output:
			// Limits of [-9 0 67 100] are -9 and 100

		}
	}

	public static (int min, int max) FindMinMax(int[] input)
	{
		if (input is null || input.Length == 0)
		{
			throw new ArgumentException("Cannot find minimum and maximum of a null or empty array.");
		}

		// Initialize min to MaxValue so every value in the input
		// is less than this initial value.
		var min = int.MaxValue;
		// Initialize max to MinValue so every value in the input
		// is greater than this initial value.
		var max = int.MinValue;
		foreach (var i in input)
		{
			if (i < min)
			{
				min = i;
			}
			if (i > max)
			{
				max = i;
			}
		}
		return (min, max);
	}

}
```

As the preceding example shows, you can work with the returned tuple instance directly or deconstruct(解构) it in separate variables.(如前面的例子所示，你可以直接使用返回的元组实例，也可以将其分解为单独的变量。)

You can also use tuple types instead of anonymous types; for example, in LINQ queries. For more information, see Choosing between anonymous and tuple types.

Typically, you use tuples to group loosely related data elements. In public APIs, consider defining a class or a structure type.(通常，使用元组对松散相关的数据元素进行分组。在公共api中，考虑定义一个类或结构类型。)


### Tuple field names
You explicitly specify tuple fields names in a tuple initialization expression or in the definition of a tuple type, as the following example shows:(你可以在元组初始化表达式或元组类型的定义中显式指定元组字段名称，如下面的例子所示:)
```C#
var t = (Sum: 4.5, Count: 3);
Console.WriteLine($"Sum of {t.Count} elements is {t.Sum}.");

(double Sum, int Count) d = (4.5, 3);
Console.WriteLine($"Sum of {d.Count} elements is {d.Sum}.");
```

If you don't specify a field name, it may be inferred from the name of the corresponding variable in a tuple initialization expression, as the following example shows:(如果没有指定字段名，则可以从元组初始化表达式中对应变量的名称推断出字段名，如下面的例子所示:)
```C#
        {

			var sum = 4.5;
			var count = 3;
			var t = (sum, count);
			Console.WriteLine($"Sum of {t.count} elements is {t.sum}."); // Sum of 3 elements is 4.5.
			Console.WriteLine($"{t.GetType()}"); // System.ValueTuple`2[System.Double,System.Int32]
		}
```

That's called tuple projection initializers. The name of a variable isn't projected onto a tuple field name in the following cases:(这称为元组投影初始化。在以下情况下，变量名不会映射到元组字段名。)
- The candidate name is a member name of a tuple type, for example, Item3, ToString, or Rest.
- The candidate name is a duplicate of another tuple field name, either explicit or implicit.

In the preceding cases, you either explicitly specify the name of a field or access a field by its default name.(在上述情况中，要么显式指定字段的名称，要么通过字段的默认名称访问字段。)

The default names of tuple fields are Item1, Item2, Item3 and so on. You can always use the default name of a field, even when a field name is specified explicitly or inferred, as the following example shows:（元组字段的默认名称是Item1、Item2、Item3等。你总是可以使用字段的默认名称，即使字段名称是显式指定或推断出来的，如下面的例子所示:）
```C#
        {
			var a = 1;
			var t = (a, b: 2, 3);
			Console.WriteLine($"The 1st element is {t.Item1} (same as {t.a})."); // The 1st element is 1 (same as 1).
			Console.WriteLine($"The 2nd element is {t.Item2} (same as {t.b})."); // The 2nd element is 2 (same as 2).
			Console.WriteLine($"The 3rd element is {t.Item3}."); // The 3rd element is 3.
		}
```

Tuple assignment and tuple equality comparisons don't take field names into account.(元组赋值和元组相等比较不考虑字段名。)

At compile time, the compiler replaces non-default field names with the corresponding default names. As a result, explicitly specified or inferred field names aren't available at run time.(编译时，编译器会用对应的默认字段名替换非默认字段名。因此，显式指定或推断的字段名在运行时不可用。)
> 编译时，使用默认的字段名,不会使用自定义的字段名

Beginning with C# 12, you can specify an alias for a tuple type with a using directive. The following example adds a global using alias for a tuple type with two integer values for an allowed Min and Max value:(从c# 12开始，你可以使用using指令为**元组类型**指定别名。下面的例子使用别名为元组类型添加一个全局变量，其中允许的Min和Max为两个整数值:)
```C#
     global using BandPass = (int Min, int Max);   
```

After declaring the alias, you can use the BandPass name as an alias for that tuple type:
```C#
global using BandPass = (int Min, int Max);

namespace Tuple_type;

public class TupleTypeStu
{
	public static void Main(string[] args)
	{
		{
			BandPass bracket = (40, 100);
			Console.WriteLine($"The bandpass filter is {bracket.Min} to {bracket.Max}"); // The bandpass filter is 40 to 100
		}
	}
}
```

An alias doesn't introduce a new type, but only creates a synonym for an existing type. You can deconstruct a tuple declared with the BandPass alias the same as you can with its underlying tuple type:(别名不会引入新类型，而只是为现有类型创建一个同义词。你可以解析使用BandPass别名声明的元组，就像解析其底层元组类型一样:)
```C#
global using BandPass = (int Min, int Max);

namespace Tuple_type;

public class TupleTypeStu
{
    public st
    atic void Main(string[] args)
    {
        {
            BandPass bracket = (40, 100);
            Console.WriteLine($"The bandpass filter is {bracket.Min} to {bracket.Max}"); // The bandpass filter is 40 to 100

            (int a, int b) = bracket;
            Console.WriteLine($"The bracket is {a} to {b}"); // The bracket is 40 to 100
        }
    }
}
```

As with tuple assignment or deconstruction, the tuple member names don't need to match; the types do.（与元组赋值和解构一样，元组成员名称不需要匹配，根据类型匹配）

Similarly, a second alias with the same arity and member types can be used interchangeably with the original alias. You could declare a second alias:（类似地，具有相同的arity和成员类型的第二个别名可以与原始别名互换使用。你可以声明第二个别名）
```C#
   using Range = (int Minimum, int Maximum);
```

You can assign a Range tuple to a BandPass tuple. As with all tuple assignment, the field names need not match, only the types and the arity(参数数量).(你可以将一个范围元组分配给一个带通元组。与所有的元组赋值一样，字段名不需要匹配，只需要匹配类型和参数数量即可。)
```C#
global using BandPass = (int Min, int Max);

using Range = (int Minimum, int Maximum);

using Range_3 = (int Minimum, int middle, int Maximum);

namespace Tuple_type;

public class TupleTypeStu
{
    public static void Main(string[] args)
    {
        {

            BandPass bracket = (40, 100);
            Console.WriteLine($"The bandpass filter is {bracket.Min} to {bracket.Max}"); // The bandpass filter is 40 to 100

            (int a, int b) = bracket;
            Console.WriteLine($"The bracket is {a} to {b}"); // The bracket is 40 to 100

            Range r = bracket;
            Console.WriteLine($"The range is {r.Minimum} to {r.Maximum}"); // The range is 40 to 100

           // Range_3 range_3 = bracket; // 异常: error CS0029: 无法将类型“(int Min, int Max)”隐式转换为“(int Minimum, int middle, int Maximum)”
        }
    }
}

```

An alias for a tuple type provides more semantic information when you use tuples. It doesn't introduce a new type. To provide type safety, you should declare a positional record instead.(使用元组时，元组类型的别名可以提供更多语义信息。它没有引入新类型。为了提供类型安全，你应该声明一个位置record。)

### Tuple assignment and deconstruction
C# supports assignment between tuple types that satisfy both of the following conditions:(C#支持元组类型之间的赋值，满足以下两个条件:)
- both tuple types have the same number of elements.(元组需要有相同数量的元素)
- for each tuple position, the type of the right-hand tuple element is the same as or implicitly(隐式转换) convertible(转换) to the type of the corresponding left-hand tuple element.(对于每个元组的的位置，右值类型必须和对应位置左值类型相同或者可以隐式转换为对应位置左值类型)

Tuple element values are assigned following the order of tuple elements. The names of tuple fields are ignored and not assigned, as the following example shows:（元组元素的值按照元组元素的顺序赋值。元组字段的名称会被忽略，也不会被赋值，如下面的例子所示:）
```C#
        {
            (int, double) t1 = (17, 3.14);
            (double First, double Second) t2 = (0.0, 1.0);
            t2 = t1;
            Console.WriteLine($"{nameof(t2)}: {t2.First} and {t2.Second}"); // t2: 17 and 3.14


            (double A, double B) t3 = (2.0, 3.0);
            t3 = t2;
            Console.WriteLine($"{nameof(t3)}: {t3.A} and {t3.B}"); //t3: 17 and 3.14
        }
```

You can also use the assignment operator = to deconstruct a tuple instance in separate variables. You can do that in many ways: （使用=操作符解构）
- Use the var keyword outside the parentheses to declare implicitly typed variables and let the compiler infer their types:(在括号外使用var关键字声明隐式类型变量，让编译器推断出它们的类型:)
  ```C#
        {
            var t = ("post office", 3.6);
            var (destination, distance) = t;
            Console.WriteLine($"Distance to {destination} is {distance} kilometers."); // Distance to post office is 3.6 kilometers.
        }
  ```

- Explicitly declare the type of each variable inside parentheses:(在括号中显式声明每个变量的类型:)
  ```C#
        {
            var t = ("post office", 3.6);
            (string destination, double distance) = t;
            Console.WriteLine($"Distance to {destination} is {distance} kilometers."); // Distance to post office is 3.6 kilometers.
        }
  ```

- Use existing variables:(使用已经存在的变量)
  ```C#
        {
            var destination = string.Empty;
            var distance = 0.0;

            var t = ("post office", 3.6);
            (destination, distance) = t;
            Console.WriteLine($"Distance to {destination} is {distance} kilometers."); // Distance to post office is 3.6 kilometers.
        }   
  ```

The destination of a deconstruct expression can include both existing variables and variables declared in the deconstruction declaration.(解构表达式的目标可以包括现有的变量和解构声明中声明的变量。)

You can also combine deconstruction with pattern matching to inspect the characteristics of fields in a tuple. The following example loops through several integers and prints those that are divisible by 3. It deconstructs the tuple result of Int32.DivRem and matches against a Remainder of 0:(你也可以结合解构和模式匹配来检查元组中字段的特征。下面的示例遍历几个整数，并打印出能被3整除的整数。它解构Int32的元组结果。与余数为0的元素匹配:)
> 检查数据特征
```C#
        {
            for (int i = 4; i < 20; i++)
            {
                // Math.cs: public static (int Quotient, int Remainder) DivRem(int left, int right); 计算两个数字的商，并返回输出参数中的余数。
                if (Math.DivRem(i, 3) is (Quotient: var q, Remainder: 0))
                {
                    Console.WriteLine($"{i} is divisible by 3, with quotient {q}");
                }
                // 6 is divisible by 3, with quotient 2
                // 9 is divisible by 3, with quotient 3
                // 12 is divisible by 3, with quotient 4
                // 15 is divisible by 3, with quotient 5
                // 18 is divisible by 3, with quotient 6
            }
        }
```

#### Tuple elements with discards
Often when deconstructing a tuple, you're interested in the values of only some elements. You can take advantage of C#'s support for discards, which are write-only variables whose values you've chosen to ignore. A discard is chosen by an underscore character ("\_") in an assignment. You can discard as many values as you like; all are represented by the single discard, \_\.（通常在解构元组时，你只对某些元素的值感兴趣。你可以利用c#对丢弃的支持，它是只写的变量，你选择忽略它们的值。丢弃值是通过赋值中的下划线字符(“\_”)选择的。你可以丢弃任意多的值;所有这些都由单个丢弃项_表示。）

The following example illustrates the use of tuples with discards. The QueryCityDataForYears method returns a six-tuple with the name of a city, its area, a year, the city's population for that year, a second year, and the city's population for that second year. The example shows the change in population between those two years. Of the data available from the tuple, we're unconcerned with the city area, and we know the city name and the two dates at design-time. As a result, we're only interested in the two population values stored in the tuple, and can handle its remaining values as discards.(下面的例子演示了如何将元组与discards一起使用。QueryCityDataForYears方法返回一个六元组，包含城市的名称、面积、年份、该城市当年的人口、第二年的人口，以及第二年的人口。这个例子显示了这两年间人口的变化。在元组中的数据中，我们不关心城市区域，我们只知道城市名称和设计时的两个日期。因此，我们只对存储在元组中的两个population值感兴趣，并可以将其剩余值作为丢弃值处理。)
```C#
    public static void Main()
    {
        var (_, _, _, pop1, _, pop2) = QueryCityDataForYears("New York City", 1960, 2010);

        Console.WriteLine($"Population change, 1960 to 2010: {pop2 - pop1:N0}"); // Population change, 1960 to 2010: 393,149
    }

    private static (string, double, int, int, int, int) QueryCityDataForYears(string name, int year1, int year2)
    {
        int population1 = 0, population2 = 0;
        double area = 0;

        if (name == "New York City")
        {
            area = 468.48;
            if (year1 == 1960)
            {
                population1 = 7781984;
            }
            if (year2 == 2010)
            {
                population2 = 8175133;
            }
            return (name, area, year1, population1, year2, population2);
        }

        return ("", 0, 0, 0, 0, 0);
    }
```

#### User-defined types
C# doesn't offer built-in support for deconstructing non-tuple types other than the record and DictionaryEntry types. However, as the author of a class, a struct, or an interface, you can allow instances of the type to be deconstructed by implementing one or more Deconstruct methods. The method returns void, and each value to be deconstructed is indicated by an out parameter in the method signature. For example, the following Deconstruct method of a Person class returns the first, middle, and last name:(除了record和DictionaryEntry类型之外，c#没有内置对解构非元组类型的支持。然而，作为类、结构体或接口的作者，您可以通过实现一个或多个解构方法来解构类型的实例。该方法返回void，每个要解构的值都由方法签名中的out参数表示。例如，下面是Person类的解构方法，它返回名、中间名和姓:)
```C#
    public void Deconstruct(out string fname, out string mname, out string lname)
```

You can then deconstruct an instance of the Person class named p with an assignment like the following code:
```C#
   var (fName, mName, lName) = p;
```

The following example overloads the Deconstruct method to return various combinations of properties of a Person object. Individual overloads return:
- A first and last name.
- A first, middle, and last name.
- A first name, a last name, a city name, and a state name.

```C#
public class TupleTypeStu
{
    public static void Main()
    {
         var p = new Person("John", "Quincy", "Adams", "Boston", "MA");

        // Deconstruct the person object.
        var (fName, lName, city, state) = p;
        Console.WriteLine($"Hello {fName} {lName} of {city}, {state}!"); // Hello John Adams of Boston, MA!
    }

}

public class Person
{
    public string FirstName { get; set; }
    public string MiddleName { get; set; }
    public string LastName { get; set; }
    public string City { get; set; }
    public string State { get; set; }

    public Person(string fname, string mname, string lname, string cityName, string stateName)
    {
        FirstName = fname;
        MiddleName = mname;
        LastName = lname;
        City = cityName;
        State = stateName;
    }

    // Return the first and last name.
    public void Deconstruct(out string fname, out string lname)
    {
        fname = FirstName;
        lname = LastName;
    }

    public void Deconstruct(out string fname, out string mname, out string lname)
    {
        fname = FirstName;
        mname = MiddleName;
        lname = LastName;
    }

    public void Deconstruct(out string fname, out string lname,
                            out string city, out string state)
    {
        fname = FirstName;
        lname = LastName;
        city = City;
        state = State;
    }
}
```

Multiple Deconstruct methods having the same number of parameters are ambiguous. You must be careful to define Deconstruct methods with different numbers of parameters, or "arity". Deconstruct methods with the same number of parameters cannot be distinguished during overload resolution.(具有相同参数数量的多个解构方法是模糊的。您必须谨慎地使用不同数量的参数(或“arity”)定义解构方法。在重载解析过程中，无法区分具有相同参数数量的解构方法。)
> 类似于JDK中的方法签名,方法名 参数个数 顺序 类型 参与方法签名。

#### User-defined type with discards
Just as you do with tuples, you can use discards to ignore selected items returned by a Deconstruct method. Each discard is defined by a variable named "\_", and a single deconstruction operation can include multiple discards.(就像处理元组一样，可以使用discards来忽略由解构方法返回的选定项。每个丢弃都由一个名为“_”的变量定义，单个解构操作可以包含多个丢弃。)

The following example deconstructs a Person object into four strings (the first and last names, the city, and the state) but discards the last name and the state.（下面的示例将Person对象结构为四个字符串，但丢弃了姓和州）
```C#
    {
        // var p = new Person("John", "Quincy", "Adams", "Boston", "MA");
        // Person 来自于本文

        var (fName, _, city, _) = p;
        Console.WriteLine($"Hello {fName} of {city}!"); // Hello John of Boston!
        return 0;
    }
```

#### Extension methods for user-defined types
If you didn't author a class, struct, or interface, you can still deconstruct objects of that type by implementing one or more Deconstruct [extension methods](../004.Methods/000.Extension%20Methods.md) to return the values in which you're interested.(如果您没有创建类、结构或接口，您仍然可以通过实现一个或多个解构扩展方法来解构该类型的对象，以返回您感兴趣的值。)
> 即 如何对不是你写的 class,struct interfact 的实例进行解构呢

The following example defines two Deconstruct extension methods for the System.Reflection.PropertyInfo class. The first returns a set of values that indicate the characteristics of the property, including its type, whether it's static or instance, whether it's read-only, and whether it's indexed. The second indicates the property's accessibility. Because the accessibility of get and set accessors can differ, Boolean values indicate whether the property has separate get and set accessors and, if it does, whether they have the same accessibility. If there's only one accessor or both the get and the set accessor have the same accessibility, the access variable indicates the accessibility of the property as a whole. Otherwise, the accessibility of the get and set accessors are indicated by the getAccess and setAccess variables.(下面的例子为System.Reflection.PropertyInfo类定义了两个解构扩展方法。第一个返回一组值，这些值指示属性的特征，包括它的类型、它是静态的还是实例的、它是否是只读的，以及它是否被索引。第二个表示属性的可访问性。因为get和set访问器的可访问性可能不同，所以布尔值指示属性是否具有单独的get和set访问器，如果有，则指示它们是否具有相同的可访问性。如果只有一个访问器，或者get和set访问器都具有相同的可访问性，则access变量表示整个属性的可访问性。否则，get和set访问器的可访问性由getAccess和setAccess变量指示。)
```C#
namespace TupleTypeStu;

using System;
using System.Collections.Generic;
using System.Reflection;

public static class ReflectionExtensions
{
    // 第一个参数,this，对比C++，Java 此类OOP语言，成员方法的第一个参数其实就是this。
    public static void Deconstruct(this PropertyInfo p, out bool isStatic,
                                   out bool isReadOnly, out bool isIndexed,
                                   out Type propertyType)
    {
        var getter = p.GetMethod;

        // Is the property read-only?
        isReadOnly = !p.CanWrite;

        // Is the property instance or static?
        isStatic = getter.IsStatic;

        // Is the property indexed?
        isIndexed = p.GetIndexParameters().Length > 0;

        // Get the property type.
        propertyType = p.PropertyType;
    }

    public static void Deconstruct(this PropertyInfo p, out bool hasGetAndSet,
                                   out bool sameAccess, out string access,
                                   out string getAccess, out string setAccess)
    {
        hasGetAndSet = sameAccess = false;
        string getAccessTemp = null;
        string setAccessTemp = null;

        MethodInfo getter = null;
        if (p.CanRead)
            getter = p.GetMethod;

        MethodInfo setter = null;
        if (p.CanWrite)
            setter = p.SetMethod;

        if (setter != null && getter != null)
            hasGetAndSet = true;

        if (getter != null)
        {
            if (getter.IsPublic)
                getAccessTemp = "public";
            else if (getter.IsPrivate)
                getAccessTemp = "private";
            else if (getter.IsAssembly)
                getAccessTemp = "internal";
            else if (getter.IsFamily)
                getAccessTemp = "protected";
            else if (getter.IsFamilyOrAssembly)
                getAccessTemp = "protected internal";
        }

        if (setter != null)
        {
            if (setter.IsPublic)
                setAccessTemp = "public";
            else if (setter.IsPrivate)
                setAccessTemp = "private";
            else if (setter.IsAssembly)
                setAccessTemp = "internal";
            else if (setter.IsFamily)
                setAccessTemp = "protected";
            else if (setter.IsFamilyOrAssembly)
                setAccessTemp = "protected internal";
        }

        // Are the accessibility of the getter and setter the same?
        if (setAccessTemp == getAccessTemp)
        {
            sameAccess = true;
            access = getAccessTemp;
            getAccess = setAccess = String.Empty;
        }
        else
        {
            access = null;
            getAccess = getAccessTemp;
            setAccess = setAccessTemp;
        }
    }
}

public class TupleTypeStu
{
    public static int Main(string[] args)
    {
        Type dateType = typeof(DateTime);
        PropertyInfo prop = dateType.GetProperty("Now");
        var (isStatic, isRO, isIndexed, propType) = prop;
        Console.WriteLine($"\nThe {dateType.FullName}.{prop.Name} property:");
        Console.WriteLine($"   PropertyType: {propType.Name}");
        Console.WriteLine($"   Static:       {isStatic}");
        Console.WriteLine($"   Read-only:    {isRO}");
        Console.WriteLine($"   Indexed:      {isIndexed}");

        Type listType = typeof(List<>);
        prop = listType.GetProperty("Item",
                                    BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static);
        var (hasGetAndSet, sameAccess, accessibility, getAccessibility, setAccessibility) = prop;
        Console.Write($"\nAccessibility of the {listType.FullName}.{prop.Name} property: ");

        if (!hasGetAndSet | sameAccess)
        {
            Console.WriteLine(accessibility);
        }
        else
        {
            Console.WriteLine($"\n   The get accessor: {getAccessibility}");
            Console.WriteLine($"   The set accessor: {setAccessibility}");
        }
        return 0;
    }

//     The System.DateTime.Now property:
//    PropertyType: DateTime
//    Static:       True
//    Read-only:    True
//    Indexed:      False

// Accessibility of the System.Collections.Generic.List`1.Item property: public

}
```

#### Extension method for system types
Some system types provide the Deconstruct method as a convenience. For example, the System.Collections.Generic.KeyValuePair<TKey,TValue> type provides this functionality. When you're iterating over a System.Collections.Generic.Dictionary<TKey,TValue> each element is a KeyValuePair<TKey, TValue> and can be deconstructed. Consider the following example:（有些系统类型为了方便提供了解构方法，如System.Collections.Generic.KeyValuePair<TKey,TValue>类型提供了此类功能。当你迭代System.Collections.Generic.KeyValuePair<TKey,TValue>时，每个元素都是一个KeyValuePair<TKey, TValue>，并且可以被解构。如下例子）
```C#
    public static int Main(string[] args)
    {
        Dictionary<string, int> snapshotCommitMap = new(StringComparer.OrdinalIgnoreCase)
        {
            ["https://github.com/dotnet/docs"] = 16_465,
            ["https://github.com/dotnet/runtime"] = 114_223,
            ["https://github.com/dotnet/installer"] = 22_436,
            ["https://github.com/dotnet/roslyn"] = 79_484,
            ["https://github.com/dotnet/aspnetcore"] = 48_386
        };

        foreach (var (repo, commitCount) in snapshotCommitMap)
        {
            Console.WriteLine(
                $"The {repo} repository had {commitCount:N0} commits as of November 10th, 2021.");
        }
        return 0;
    }
```

You can add a Deconstruct method to system types that don't have one. Consider the following extension method:
```C#
public static class NullableExtensions
{
    public static void Deconstruct<T>(
        this T? nullable,
        out bool hasValue,
        out T value) where T : struct
    {
        hasValue = nullable.HasValue;
        value = nullable.GetValueOrDefault();
    }
}
```

This extension method allows all Nullable\<T> types to be deconstructed into a tuple of (bool hasValue, T value). The following example shows code that uses this extension method:
```C#
public static class NullableExtensions
{
    // 无此方法，如下main方法执行报错
    public static void Deconstruct<T>(
        this T? nullable,
        out bool hasValue,
        out T value) where T : struct
    {
        hasValue = nullable.HasValue;
        value = nullable.GetValueOrDefault();
    }
}


public class TupleTypeStu
{
    public static int Main(string[] args)
    {
        DateTime? questionableDateTime = default;
        var (hasValue, value) = questionableDateTime;
        Console.WriteLine($"{{ HasValue = {hasValue}, Value = {value} }}"); // { HasValue = False, Value = 1/1/0001 12:00:00 AM }

        questionableDateTime = DateTime.Now;
        (hasValue, value) = questionableDateTime;
        Console.WriteLine($"{{ HasValue = {hasValue}, Value = {value} }}"); // { HasValue = True, Value = 8/17/2024 2:04:18 PM }

        return 0;
    }
}
```

#### record types
When you declare a record type by using two or more positional parameters, the compiler creates a Deconstruct method with an out parameter for each positional parameter in the record declaration. For more information, see Positional syntax for [property definition](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#positional-syntax-for-property-definition) and Deconstructor behavior in [derived records](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record#deconstructor-behavior-in-derived-records).


### Tuple equality
Tuple types support the == and != operators. These operators compare members of the left-hand operand with the corresponding members of the right-hand operand following the order of tuple elements.
(元组类型支持==和!=操作符。这些运算符按照元组元素的顺序比较左操作数的成员和右操作数的相应成员。)
```C#
        {
            (int a, byte b) left = (5, 10);
            (long a, int b) right = (5, 10);
            Console.WriteLine(left == right);  // output: True
            Console.WriteLine(left != right);  // output: False

            var t1 = (A: 5, B: 10);
            var t2 = (B: 5, A: 10);
            Console.WriteLine(t1 == t2);  // output: True
            Console.WriteLine(t1 != t2);  // output: False
        }
```

As the preceding example shows, the == and != operations don't take into account tuple field names.(如上例所示，==和!=操作不考虑元组字段名。)

Two tuples are comparable when both of the following conditions are satisfied:(两个元组在满足以下两个条件时是可比较的:)
- Both tuples have the same number of elements. For example, t1 != t2 doesn't compile if t1 and t2 have different numbers of elements.
- For each tuple position, the corresponding elements from the left-hand and right-hand tuple operands are comparable with the == and != operators. For example, (1, (2, 3)) == ((1, 2), 3) doesn't compile because 1 isn't comparable with (1, 2).

The == and != operators compare tuples in short-circuiting(短路) way. That is, an operation stops as soon as it meets a pair of non equal elements or reaches the ends of tuples. However, before any comparison, all tuple elements are evaluated(评估), as the following example shows:
```C#
    public static void Main(string[] args)
    {
        {
            Console.WriteLine((Display(1), Display(2)) == (Display(3), Display(4)));

            // ➜  tuple_type dotnet run                      
            // 1
            // 2
            // 3
            // 4
            // False
            // 先算出每个元素的值，再进行比较
        }
    }

    public static int Display(int s)
    {
        Console.WriteLine(s);
        return s;
    }
```

### Tuples as out parameters
Typically, you refactor a method that has out parameters into a method that returns a tuple. However, there are cases in which an out parameter can be of a tuple type. The following example shows how to work with tuples as out parameters:(通常，你需要重构一个有参数的方法，使其返回一个元组。然而，在某些情况下，out参数可以是元组类型。下面的例子展示了如何使用元组作为输出参数:)
```C#
        {
            var limitsLookup = new Dictionary<int, (int Min, int Max)>()
            {
                [2] = (4, 10),
                [4] = (10, 20),
                [6] = (0, 23)
            };

            if (limitsLookup.TryGetValue(4, out (int Min, int Max) limits))
            {
                Console.WriteLine($"Found limits: min is {limits.Min}, max is {limits.Max}"); // Found limits: min is 10, max is 20
            }
        }
```

### Tuples vs System.Tuple
C# tuples, which are backed by System.ValueTuple types, are different from tuples that are represented by System.Tuple types. The main differences are as follows:(C# tuples , 由System.ValueTuple类型支持，与System.Tuple类型不同。主要有如下区别:)
- System.ValueTuple types are value types. System.Tuple types are reference types.
- System.ValueTuple types are mutable(可变的). System.Tuple types are immutable.
- Data members of System.ValueTuple types are fields. Data members of System.Tuple types are properties.








## 参考资料
1. [Tuple types (C# reference)](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-tuples)
2. [Deconstructing tuples and other types](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/functional/deconstruct)
