# Extension Methods
## 摘要 


## 文档内容
Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are static methods, but they're called as if they were instance methods on the extended type. For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.（扩展方法使您能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。扩展方法是静态方法，但是调用它们时就好像它们是扩展类型上的实例方法一样。对于用c#、f#和Visual Basic编写的客户端代码，调用扩展方法和在类型中定义的方法之间没有明显的区别。）

The most common extension methods are the LINQ standard query operators that add query functionality to the existing System.Collections.IEnumerable and System.Collections.Generic.IEnumerable\<T\> types. To use the standard query operators, first bring them into scope with a using System.Linq directive. Then any type that implements IEnumerable\<T\> appears to have instance methods such as GroupBy, OrderBy, Average, and so on. You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an IEnumerable\<T\> type such as List\<T\> or Array.(最常见的扩展方法是LINQ标准查询操作符，它向现有的System.Collections.IEnumerable和System.Collections.Generic.IEnumerable\<T\> 添加查询功能。要使用标准的查询操作符，首先使用 using System.Linq将他们纳入范围，然后任何实现了IEnumerable\<T\>似乎都有了实例方法，如GroupBy, OrderBy, Average等，当你在IEnumerable\<T\>类型（List\<T\> 或 Array）实例后输入 "."的时候，你可以在IntelliSense语句补全中看到这些额外的方法。)

### OrderBy Example
The following example shows how to call the standard query operator OrderBy method on an array of integers. The expression in parentheses is a lambda expression. Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods. For more information, see Lambda Expressions.（下面的示例显示如何在整数数组上调用标准查询操作符OrderBy方法。括号中的表达式是lambda表达式。许多标准查询操作符将lambda表达式作为参数，但这不是扩展方法的要求）
```C#
    public static int Main(string[] args)
    {



        int[] ints = [10, 45, 15, 39, 21, 26];
        var result = ints.OrderBy(g => g);
        foreach (var i in result)
        {
            System.Console.Write(i + " ");
        }
        // 10 15 21 26 39 45

        return 0;
    }
```

Extension methods are defined as static methods but are called by using instance method syntax. Their first parameter specifies which type the method operates on. The parameter follows the this modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a using directive.(扩展方法定义为静态方法，但通过使用实例方法语法调用。它们的第一个参数指定方法操作的类型。参数跟在this修饰符后面。只有在使用using指令显式地将命名空间导入源代码时，扩展方法才会出现在作用域中。)
> 拓展方法是有作用域的


The following example shows an extension method defined for the System.String class. It's defined inside a non-nested, non-generic static class:
```C#
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this string str)
        {
            return str.Split(new char[] { ' ', '.', '?' },
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }
}
```

The WordCount extension method can be brought into scope with this using directive:
> 将拓展方法传递到using指令所在的作用域
```C#
using ExtensionMethods;
```

And it can be called from an application by using this syntax:
```C#
namespace Extension_method;

using ExtensionMethods;

public class TupleTypeStu
{
    public static int Main(string[] args)
    {
        string s = "Hello Extension Methods";
        int i = s.WordCount();
        System.Console.WriteLine($"---> {i} \n"); // ---> 3 

        return 0;
    }

}
```

You invoke the extension method in your code with instance method syntax. The intermediate language (IL) generated by the compiler translates your code into a call on the static method. The principle of encapsulation isn't really being violated. Extension methods can't access private variables in the type they're extending.(在代码中使用实例方法语法调用扩展方法。编译器生成的中间语言(IL)将代码转换为对静态方法的调用。封装原则并没有真正被违背。扩展方法不能访问它们正在扩展的类型中的私有变量。)

Both the MyExtensions class and the WordCount method are static, and it can be accessed like all other static members. The WordCount method can be invoked like other static methods as follows:(MyExtensions类和WordCount方法都是静态的，可以像访问所有其他静态成员一样访问它。WordCount方法可以像其他静态方法一样调用，如下所示:)
```C#
namespace Extension_method;

using ExtensionMethods;

public class TupleTypeStu
{
    public static int Main(string[] args)
    {
        string s = "Hello Extension Methods";
        int i = s.WordCount();
        System.Console.WriteLine($"---> {i} \n"); // ---> 3 

        int j = MyExtensions.WordCount(s);
        System.Console.WriteLine($"j---> {j} \n"); //j---> 3 

        return 0;
    }

}
```

The preceding C# code:(前面的C#代码)
- Declares and assigns a new string named s with a value of "Hello Extension Methods".
- Calls MyExtensions.WordCount given argument s.

In general, you'll probably be calling extension methods far more often than implementing your own. Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code. To enable extension methods for a particular type, just add a using directive for the namespace in which the methods are defined. For example, to use the standard query operators, add this using directive to your code:(一般来说，调用扩展方法的次数可能比实现自己的方法要频繁得多。因为扩展方法是通过使用实例方法语法调用的，所以在客户机代码中使用它们不需要特殊的知识。要启用特定类型的扩展方法，只需为定义方法的名称空间添加一个using指令。例如，要使用标准查询操作符，将using指令添加到代码中:)
```C#
using System.Linq;
```

(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most IEnumerable\<T\> types.((你可能还需要添加对System.Core.dll的引用。)您将注意到，标准查询操作符现在作为附加方法出现在IntelliSense中，可用于大多数IEnumerable\<T\>类型。)

### Binding Extension Methods at Compile Time
You can use extension methods to extend a class or interface, but not to override them. An extension method with the same name and signature as an interface or class method will never be called. At compile time, extension methods always have lower priority than instance methods defined in the type itself. In other words, if a type has a method named Process(int i), and you have an extension method with the same signature, the compiler will always bind to the instance method. When the compiler encounters a method invocation, it first looks for a match in the type's instance methods. If no match is found, it searches for any extension methods that are defined for the type, and bind to the first extension method that it finds.(您可以使用扩展方法来扩展类或接口，但不能覆盖它们。永远不会调用与接口或类方法具有相同名称和签名的扩展方法。在编译时，扩展方法的优先级总是低于在类型本身中定义的实例方法。换句话说，如果一个类型有一个名为Process(int i)的方法，并且您有一个具有相同签名的扩展方法，那么编译器将始终绑定到实例方法。当编译器遇到方法调用时，它首先在类型的实例方法中查找匹配项。如果没有找到匹配项，它将搜索为该类型定义的任何扩展方法，并绑定到它找到的第一个扩展方法。)
> 方法分派顺序： 优先实例方法，再拓展方法

### Example
> 方法分派规则


The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method. The static class Extensions contains extension methods defined for any type that implements IMyInterface. Classes A, B, and C all implement the interface.(下面的示例演示了c#编译器在确定是将方法调用绑定到类型上的实例方法还是绑定到扩展方法时所遵循的规则。静态类Extensions包含为实现IMyInterface的任何类型定义的扩展方法。类A、B和C都实现了接口。)

The MethodB extension method is never called because its name and signature exactly match methods already implemented by the classes.(永远不会调用MethodB扩展方法，因为它的名称和签名与类已经实现的方法完全匹配。)

When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.(当编译器找不到具有匹配签名的实例方法时，它将绑定到匹配的扩展方法(如果存在)。)
```C#
// Define an interface named IMyInterface.
namespace DefineIMyInterface
{
    public interface IMyInterface
    {
        // Any class that implements IMyInterface must define a method
        // that matches the following signature.
        void MethodB();
    }
}

// Define extension methods for IMyInterface.
namespace Extensions
{
    using System;
    using DefineIMyInterface;

    // The following extension methods can be accessed by instances of any
    // class that implements IMyInterface.
    public static class Extension
    {
        public static void MethodA(this IMyInterface myInterface, int i)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, int i)");
        }

        public static void MethodA(this IMyInterface myInterface, string s)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, string s)");
        }

        // This method is never called in ExtensionMethodsDemo1, because each
        // of the three classes A, B, and C implements a method named MethodB
        // that has a matching signature.
        public static void MethodB(this IMyInterface myInterface)
        {
            Console.WriteLine
                ("Extension.MethodB(this IMyInterface myInterface)");
        }
    }
}

// Define three classes that implement IMyInterface, and then use them to test
// the extension methods.
namespace ExtensionMethodsDemo1
{
    using System;
    using Extensions;
    using DefineIMyInterface;

    class A : IMyInterface
    {
        public void MethodB() { Console.WriteLine("A.MethodB()"); }
    }

    class B : IMyInterface
    {
        public void MethodB() { Console.WriteLine("B.MethodB()"); }
        public void MethodA(int i) { Console.WriteLine("B.MethodA(int i)"); }
    }

    class C : IMyInterface
    {
        public void MethodB() { Console.WriteLine("C.MethodB()"); }
        public void MethodA(object obj)
        {
            Console.WriteLine("C.MethodA(object obj)");
        }
    }

    class ExtMethodDemo
    {
        static void Main(string[] args)
        {
            // Declare an instance of class A, class B, and class C.
            A a = new A();
            B b = new B();
            C c = new C();

            // For a, b, and c, call the following methods:
            //      -- MethodA with an int argument
            //      -- MethodA with a string argument
            //      -- MethodB with no argument.

            // A contains no MethodA, so each call to MethodA resolves to
            // the extension method that has a matching signature.
            a.MethodA(1);           // Extension.MethodA(IMyInterface, int)
            a.MethodA("hello");     // Extension.MethodA(IMyInterface, string)

            // A has a method that matches the signature of the following call
            // to MethodB.
            a.MethodB();            // A.MethodB()

            // B has methods that match the signatures of the following
            // method calls.
            b.MethodA(1);           // B.MethodA(int)
            b.MethodB();            // B.MethodB()

            // B has no matching method for the following call, but
            // class Extension does.
            b.MethodA("hello");     // Extension.MethodA(IMyInterface, string)

            // C contains an instance method that matches each of the following
            // method calls.
            c.MethodA(1);           // C.MethodA(object)
            c.MethodA("hello");     // C.MethodA(object)
            c.MethodB();            // C.MethodB()
        }
    }
}
```




### 附录
#### How to implement and call a custom extension method.


