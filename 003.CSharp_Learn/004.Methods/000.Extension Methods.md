# Extension Methods
## 摘要 


## 文档内容
Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type. Extension methods are static methods, but they're called as if they were instance methods on the extended type. For client code written in C#, F# and Visual Basic, there's no apparent difference between calling an extension method and the methods defined in a type.（扩展方法使您能够向现有类型“添加”方法，而无需创建新的派生类型、重新编译或以其他方式修改原始类型。扩展方法是静态方法，但是调用它们时就好像它们是扩展类型上的实例方法一样。对于用c#、f#和Visual Basic编写的客户端代码，调用扩展方法和在类型中定义的方法之间没有明显的区别。）

The most common extension methods are the LINQ standard query operators that add query functionality to the existing System.Collections.IEnumerable and System.Collections.Generic.IEnumerable\<T\> types. To use the standard query operators, first bring them into scope with a using System.Linq directive. Then any type that implements IEnumerable\<T\> appears to have instance methods such as GroupBy, OrderBy, Average, and so on. You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an IEnumerable\<T\> type such as List\<T\> or Array.(最常见的扩展方法是LINQ标准查询操作符，它向现有的System.Collections.IEnumerable和System.Collections.Generic.IEnumerable\<T\> 添加查询功能。要使用标准的查询操作符，首先使用 using System.Linq将他们纳入范围，然后任何实现了IEnumerable\<T\>似乎都有了实例方法，如GroupBy, OrderBy, Average等，当你在IEnumerable\<T\>类型（List\<T\> 或 Array）实例后输入 "."的时候，你可以在IntelliSense语句补全中看到这些额外的方法。)

### OrderBy Example
The following example shows how to call the standard query operator OrderBy method on an array of integers. The expression in parentheses is a lambda expression. Many standard query operators take lambda expressions as parameters, but this isn't a requirement for extension methods. For more information, see Lambda Expressions.（下面的示例显示如何在整数数组上调用标准查询操作符OrderBy方法。括号中的表达式是lambda表达式。许多标准查询操作符将lambda表达式作为参数，但这不是扩展方法的要求）
```C#
    public static int Main(string[] args)
    {



        int[] ints = [10, 45, 15, 39, 21, 26];
        var result = ints.OrderBy(g => g);
        foreach (var i in result)
        {
            System.Console.Write(i + " ");
        }
        // 10 15 21 26 39 45

        return 0;
    }
```

Extension methods are defined as static methods but are called by using instance method syntax. Their first parameter specifies which type the method operates on. The parameter follows the this modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a using directive.(扩展方法定义为静态方法，但通过使用实例方法语法调用。它们的第一个参数指定方法操作的类型。参数跟在this修饰符后面。只有在使用using指令显式地将命名空间导入源代码时，扩展方法才会出现在作用域中。)
> 拓展方法是有作用域的


The following example shows an extension method defined for the System.String class. It's defined inside a non-nested, non-generic static class:
```C#
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static int WordCount(this string str)
        {
            return str.Split(new char[] { ' ', '.', '?' },
                             StringSplitOptions.RemoveEmptyEntries).Length;
        }
    }
}
```

The WordCount extension method can be brought into scope with this using directive:
> 将拓展方法传递到using指令所在的作用域
```C#
using ExtensionMethods;
```

And it can be called from an application by using this syntax:
```C#
namespace Extension_method;

using ExtensionMethods;

public class TupleTypeStu
{
    public static int Main(string[] args)
    {
        string s = "Hello Extension Methods";
        int i = s.WordCount();
        System.Console.WriteLine($"---> {i} \n"); // ---> 3 

        return 0;
    }

}
```

You invoke the extension method in your code with instance method syntax. The intermediate language (IL) generated by the compiler translates your code into a call on the static method. The principle of encapsulation isn't really being violated. Extension methods can't access private variables in the type they're extending.(在代码中使用实例方法语法调用扩展方法。编译器生成的中间语言(IL)将代码转换为对静态方法的调用。封装原则并没有真正被违背。扩展方法不能访问它们正在扩展的类型中的私有变量。)

Both the MyExtensions class and the WordCount method are static, and it can be accessed like all other static members. The WordCount method can be invoked like other static methods as follows:(MyExtensions类和WordCount方法都是静态的，可以像访问所有其他静态成员一样访问它。WordCount方法可以像其他静态方法一样调用，如下所示:)
```C#
namespace Extension_method;

using ExtensionMethods;

public class TupleTypeStu
{
    public static int Main(string[] args)
    {
        string s = "Hello Extension Methods";
        int i = s.WordCount();
        System.Console.WriteLine($"---> {i} \n"); // ---> 3 

        int j = MyExtensions.WordCount(s);
        System.Console.WriteLine($"j---> {j} \n"); //j---> 3 

        return 0;
    }

}
```

The preceding C# code:(前面的C#代码)
- Declares and assigns a new string named s with a value of "Hello Extension Methods".
- Calls MyExtensions.WordCount given argument s.

In general, you'll probably be calling extension methods far more often than implementing your own. Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code. To enable extension methods for a particular type, just add a using directive for the namespace in which the methods are defined. For example, to use the standard query operators, add this using directive to your code:(一般来说，调用扩展方法的次数可能比实现自己的方法要频繁得多。因为扩展方法是通过使用实例方法语法调用的，所以在客户机代码中使用它们不需要特殊的知识。要启用特定类型的扩展方法，只需为定义方法的名称空间添加一个using指令。例如，要使用标准查询操作符，将using指令添加到代码中:)
```C#
using System.Linq;
```

(You may also have to add a reference to System.Core.dll.) You'll notice that the standard query operators now appear in IntelliSense as additional methods available for most IEnumerable\<T\> types.((你可能还需要添加对System.Core.dll的引用。)您将注意到，标准查询操作符现在作为附加方法出现在IntelliSense中，可用于大多数IEnumerable\<T\>类型。)

### Binding Extension Methods at Compile Time
You can use extension methods to extend a class or interface, but not to override them. An extension method with the same name and signature as an interface or class method will never be called. At compile time, extension methods always have lower priority than instance methods defined in the type itself. In other words, if a type has a method named Process(int i), and you have an extension method with the same signature, the compiler will always bind to the instance method. When the compiler encounters a method invocation, it first looks for a match in the type's instance methods. If no match is found, it searches for any extension methods that are defined for the type, and bind to the first extension method that it finds.(您可以使用扩展方法来扩展类或接口，但不能覆盖它们。永远不会调用与接口或类方法具有相同名称和签名的扩展方法。在编译时，扩展方法的优先级总是低于在类型本身中定义的实例方法。换句话说，如果一个类型有一个名为Process(int i)的方法，并且您有一个具有相同签名的扩展方法，那么编译器将始终绑定到实例方法。当编译器遇到方法调用时，它首先在类型的实例方法中查找匹配项。如果没有找到匹配项，它将搜索为该类型定义的任何扩展方法，并绑定到它找到的第一个扩展方法。)
> 方法分派顺序： 优先实例方法，再拓展方法

### Example
> 方法分派规则

The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method. The static class Extensions contains extension methods defined for any type that implements IMyInterface. Classes A, B, and C all implement the interface.(下面的示例演示了c#编译器在确定是将方法调用绑定到类型上的实例方法还是绑定到扩展方法时所遵循的规则。静态类Extensions包含为实现IMyInterface的任何类型定义的扩展方法。类A、B和C都实现了接口。)

The MethodB extension method is never called because its name and signature exactly match methods already implemented by the classes.(永远不会调用MethodB扩展方法，因为它的名称和签名与类已经实现的方法完全匹配。)

When the compiler can't find an instance method with a matching signature, it will bind to a matching extension method if one exists.(当编译器找不到具有匹配签名的实例方法时，它将绑定到匹配的扩展方法(如果存在)。)
```C#
// Define an interface named IMyInterface.
namespace DefineIMyInterface
{
    public interface IMyInterface
    {
        // Any class that implements IMyInterface must define a method
        // that matches the following signature.
        void MethodB();
    }
}

// Define extension methods for IMyInterface.
namespace Extensions
{
    using System;
    using DefineIMyInterface;

    // The following extension methods can be accessed by instances of any
    // class that implements IMyInterface.
    public static class Extension
    {
        public static void MethodA(this IMyInterface myInterface, int i)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, int i)");
        }

        public static void MethodA(this IMyInterface myInterface, string s)
        {
            Console.WriteLine
                ("Extension.MethodA(this IMyInterface myInterface, string s)");
        }

        // This method is never called in ExtensionMethodsDemo1, because each
        // of the three classes A, B, and C implements a method named MethodB
        // that has a matching signature.
        public static void MethodB(this IMyInterface myInterface)
        {
            Console.WriteLine
                ("Extension.MethodB(this IMyInterface myInterface)");
        }
    }
}

// Define three classes that implement IMyInterface, and then use them to test
// the extension methods.
namespace ExtensionMethodsDemo1
{
    using System;
    using Extensions;
    using DefineIMyInterface;

    class A : IMyInterface
    {
        public void MethodB() { Console.WriteLine("A.MethodB()"); }
    }

    class B : IMyInterface
    {
        public void MethodB() { Console.WriteLine("B.MethodB()"); }
        public void MethodA(int i) { Console.WriteLine("B.MethodA(int i)"); }
    }

    class C : IMyInterface
    {
        public void MethodB() { Console.WriteLine("C.MethodB()"); }
        public void MethodA(object obj)
        {
            Console.WriteLine("C.MethodA(object obj)");
        }
    }

    class ExtMethodDemo
    {
        static void Main(string[] args)
        {
            // Declare an instance of class A, class B, and class C.
            A a = new A();
            B b = new B();
            C c = new C();

            // For a, b, and c, call the following methods:
            //      -- MethodA with an int argument
            //      -- MethodA with a string argument
            //      -- MethodB with no argument.

            // A contains no MethodA, so each call to MethodA resolves to
            // the extension method that has a matching signature.
            a.MethodA(1);           // Extension.MethodA(IMyInterface, int)
            a.MethodA("hello");     // Extension.MethodA(IMyInterface, string)

            // A has a method that matches the signature of the following call
            // to MethodB.
            a.MethodB();            // A.MethodB()

            // B has methods that match the signatures of the following
            // method calls.
            b.MethodA(1);           // B.MethodA(int)
            b.MethodB();            // B.MethodB()

            // B has no matching method for the following call, but
            // class Extension does.
            b.MethodA("hello");     // Extension.MethodA(IMyInterface, string)

            // C contains an instance method that matches each of the following
            // method calls.
            c.MethodA(1);           // C.MethodA(object)
            c.MethodA("hello");     // C.MethodA(object)
            c.MethodB();            // C.MethodB()
        }
    }
}
```

### Common Usage Patterns
#### Collection Functionality
In the past, it was common to create "Collection Classes" that implemented the System.Collections.Generic.IEnumerable\<T> interface for a given type and contained functionality that acted on collections of that type. While there's nothing wrong with creating this type of collection object, the same functionality can be achieved by using an extension on the System.Collections.Generic.IEnumerable\<T>. Extensions have the advantage of allowing the functionality to be called from any collection such as an System.Array or System.Collections.Generic.List\<T> that implements System.Collections.Generic.IEnumerable\<T> on that type. An example of this using an Array of Int32 can be found earlier in this article(过去，通常创建“集合类”，这些类实现给定类型的 System.Collections.Generic. IEnumerable\<T> 接口，并包含对该类型的集合起作用的功能。虽然创建这种类型的集合对象没有什么问题，但可以通过对 System.Collections.Generic.IEnumerable\<T> 使用扩展来实现相同的功能。扩展的优点是允许从任何集合（例如在该类型上实现 System.Collections.Generic. IEnumerable\<T> 的 System.Array 或 System.Collections.Generic.List\<T>）调用该功能。本文前面有一个使用 Int32 数组的示例)
> 即之前是通过实现接口并编写对应的功能，那么现在就不用创建实现类了，直接就可以使用拓展来实现了。


#### Layer-Specific Functionality
When using an Onion Architecture or other layered application design, it's common to have a set of Domain Entities or Data Transfer Objects that can be used to communicate across application boundaries. These objects generally contain no functionality, or only minimal functionality that applies to all layers of the application. Extension methods can be used to add functionality that is specific to each application layer without loading the object down with methods not needed or wanted in other layers.（使用洋葱架构或其他分层应用程序设计时，通常会有一组域实体或数据传输对象可用于跨应用程序边界进行通信。这些对象通常不包含任何功能，或仅包含适用于应用程序所有层的最低限度的功能。扩展方法可用于添加特定于每个应用程序层的功能，而无需使用其他层不需要或不需要的方法加载对象。）
```C#
public class DomainEntity
{
    public int Id { get; set; }
    public string FirstName { get; set; }
    public string LastName { get; set; }
}

static class DomainEntityExtensions
{
    static string FullName(this DomainEntity value)
        => $"{value.FirstName} {value.LastName}";
}
```

#### Extending Predefined Types(拓展预定义类型)
Rather than creating new objects when reusable functionality needs to be created, we can often extend an existing type, such as a .NET or CLR type. As an example, if we don't use extension methods, we might create an Engine or Query class to do the work of executing a query on a SQL Server that may be called from multiple places in our code. However we can instead extend the System.Data.SqlClient.SqlConnection class using extension methods to perform that query from anywhere we have a connection to a SQL Server. Other examples might be to add common functionality to the System.String class, extend the data processing capabilities of the System.IO.Stream object, and System.Exception objects for specific error handling functionality. These types of use-cases are limited only by your imagination and good sense.(当需要创建可重用功能时，我们通常可以扩展现有类型（例如 .NET 或 CLR 类型），而不是创建新对象。例如，如果我们不使用扩展方法，我们可能会创建一个 Engine 或 Query 类来执行 SQL Server 上的查询，该查询可能会从我们代码中的多个位置调用。但是，我们可以使用扩展方法扩展 System.Data.SqlClient.SqlConnection 类，以便从任何与 SQL Server 连接的地方执行该查询。其他示例可能是向 System.String 类添加常用功能，扩展 System.IO.Stream 对象的数据处理功能，以及 System.Exception 对象以实现特定的错误处理功能。这些类型的用例仅受您的想象力和常识的限制。)

Extending predefined types can be difficult with struct types because they're passed by value to methods. That means any changes to the struct are made to a copy of the struct. Those changes aren't visible once the extension method exits. You can add the ref modifier to the first argument making it a ref extension method. The ref keyword can appear before or after the this keyword without any semantic differences. Adding the ref modifier indicates that the first argument is passed by reference. This enables you to write extension methods that change the state of the struct being extended (note that private members aren't accessible). Only value types or generic types constrained to struct (see struct constraint for more information) are allowed as the first parameter of a ref extension method. The following example shows how to use a ref extension method to directly modify a built-in type without the need to reassign the result or pass it through a function with the ref keyword:(使用结构类型扩展预定义类型可能很困难，因为它们是通过值传递给方法的。这意味着对结构的任何更改都是对结构的副本进行的。扩展方法退出后，这些更改将不可见。您可以将 ref 修饰符添加到第一个参数，使其成为 ref 扩展方法。ref 关键字可以出现在 this 关键字之前或之后，没有任何语义差异。添加 ref 修饰符表示第一个参数是通过引用传递的。这使您可以编写更改正在扩展的结构状态的扩展方法（请注意，私有成员不可访问）。只有值类型或约束为结构的泛型类型（有关详细信息，请参阅结构约束）才允许作为 ref 扩展方法的第一个参数。以下示例演示如何使用 ref 扩展方法直接修改内置类型，而无需重新分配结果或使用 ref 关键字将其传递给函数：)
> struct 是值传递，添加了ref关键字后，变为了引用传递

```C#
public static class IntExtensions
{
    public static void Increment(this int number)
        => number++;

    // Take note of the extra ref keyword here
    public static void RefIncrement(this ref int number)
        => number++;
}

public static class IntProgram
{
    public static void Test()
    {
        int x = 1;

        // Takes x by value leading to the extension method
        // Increment modifying its own copy, leaving x unchanged
        x.Increment();
        Console.WriteLine($"x is now {x}"); // x is now 1

        // Takes x by reference leading to the extension method
        // RefIncrement changing the value of x directly
        x.RefIncrement();
        Console.WriteLine($"x is now {x}"); // x is now 2
    }
}
```

This next example demonstrates ref extension methods for user-defined struct types:(下面的例子演示了用户定义的结构类型的ref扩展方法:)
```C#
public struct Account
{
    public uint id;
    public float balance;

    private int secret;
}

public static class AccountExtensions
{
    // ref keyword can also appear before the this keyword
    public static void Deposit(ref this Account account, float amount)
    {
        account.balance += amount;

        // The following line results in an error as an extension
        // method is not allowed to access private members
        // account.secret = 1; // CS0122
    }
}

public static class AccountProgram
{
    public static void Test()
    {
        Account account = new()
        {
            id = 1,
            balance = 100f
        };

        Console.WriteLine($"I have ${account.balance}"); // I have $100

        account.Deposit(50f);
        Console.WriteLine($"I have ${account.balance}"); // I have $150
    }
}
```

#### General Guidelines(一般准则)
While it's still considered preferable to add functionality by modifying an object's code or deriving a new type whenever it's reasonable and possible to do so, extension methods have become a crucial option for creating reusable functionality throughout the .NET ecosystem. For those occasions when the original source isn't under your control, when a derived object is inappropriate or impossible, or when the functionality shouldn't be exposed beyond its applicable scope, Extension methods are an excellent choice.(尽管在合理且可行的情况下，通过修改对象代码或派生新类型来添加功能仍被视为一种可取的做法，但扩展方法已成为在整个 .NET 生态系统中创建可重用功能的关键选项。当原始源不受您控制、派生对象不合适或无法使用，或者功能不应超出其适用范围时，扩展方法是一种极好的选择。)

When using an extension method to extend a type whose source code you aren't in control of, you run the risk that a change in the implementation of the type will cause your extension method to break.(当使用扩展方法来扩展您无法控制其源代码的类型时，您将面临类型实现的更改导致扩展方法中断的风险。)

If you do implement extension methods for a given type, remember the following points:(如果确实为给定类型实现了扩展方法，请记住以下几点：)
- An extension method is not called if it has the same signature as a method defined in the type.(如果扩展方法具有与类型中定义的方法相同的签名，则不会调用它。)
- Extension methods are brought into scope at the namespace level. For example, if you have multiple static classes that contain extension methods in a single namespace named Extensions, they'll all be brought into scope by the using Extensions; directive.(扩展方法在命名空间级别被带入范围。例如，如果您在名为 Extensions 的单个命名空间中有多个包含扩展方法的静态类，则它们都将通过 using Extensions; 指令被带入范围。)

For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly. If you want to add significant functionality to a library for which you own the source code, follow the .NET guidelines for assembly versioning.(对于您实现的类库，您不应使用扩展方法来避免增加程序集的版本号。如果您要向您拥有源代码的库添加重要功能，请遵循 .NET 程序集版本控制指南。)


### 附录
#### How to implement and call a custom extension method.
This topic shows how to implement your own extension methods for any .NET type. Client code can use your extension methods by adding a reference to the DLL that contains them, and adding a using directive that specifies the namespace in which the extension methods are defined.(本主题介绍如何为任何 .NET 类型实现您自己的扩展方法。客户端代码可以通过添加对包含扩展方法的 DLL 的引用，并添加指定定义扩展方法的命名空间的 using 指令来使用您的扩展方法。)

##### To define and call the extension method



## 参考资料
1. [Extension Methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
2. [How to implement and call a custom extension method](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)
