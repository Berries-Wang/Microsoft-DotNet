# The C# type system
C# 是强类型语言，变量和常量必须有自己的类型。

## 类型能够提供的信息
The information stored in a type can include the following items:
- The storage space that a variable of the type requires.
- The maximum and minimum values that it can represent.
- The members (methods, fields, events, and so on) that it contains.
- The base type it inherits from.
- The interface(s) it implements.
- The kinds of operations that are permitted.


## The common type system

It's important to understand two fundamental points about the type system in .NET:(了解.net中类型系统的两个基本要点是很重要的:)
- It supports the principle of inheritance. Types can derive from other types, called base types. The derived type inherits (with some restrictions) the methods, properties, and other members of the base type. The base type can in turn derive from some other type, in which case the derived type inherits the members of both base types in its inheritance hierarchy. All types, including built-in numeric types such as System.Int32 (C# keyword: int), derive ultimately from a single base type, which is System.Object (C# keyword: object). This unified type hierarchy is called the Common Type System (CTS). For more information about inheritance in C#, see Inheritance.(它支持继承原则。类型可以从其他类型派生，称为基类型。派生类型继承(有一些限制)基类型的方法、属性和其他成员。基类型又可以从其他类型派生，在这种情况下，派生类型在其继承层次结构中继承两个基类型的成员。所有类型，包括内置的数字类型，如System.Int32 (c#关键字:int)，最终派生自一个基类型，即System.Object(c#关键字:Object)。这种统一的类型层次结构称为公共类型系统(CTS)。有关c#[中继承的更多信息，请参见Inheritance。](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance))

- Each type in the CTS is defined as either a value type or a reference type. These types include all custom types in the .NET class library and also your own user-defined types. Types that you define by using the struct keyword are value types; all the built-in numeric types are structs. Types that you define by using the class or record keyword are reference types. Reference types and value types have different compile-time rules, and different run-time behavior.(CTS中的每个类型都定义为值类型或引用类型。这些类型包括.net类库中的所有自定义类型以及您自己的用户定义类型。使用struct关键字定义的类型是值类型;所有内置的数值类型都是结构体。使用class或record关键字定义的类型是引用类型。引用类型和值类型具有不同的编译时规则和不同的运行时行为。)


The following illustration(插图) shows the relationship between value types and reference types in the CTS.

- ![value-reference-types-common-type-system.png](./IMGS/value-reference-types-common-type-system.png)

### 引用类型和值类型
+ [class 是引用类型]A class is a reference type. When an object of the type is created, the variable to which the object is assigned holds only a reference to that memory. When the object reference is assigned to a new variable, the new variable refers to the original object. Changes made through one variable are reflected in the other variable because they both refer to the same data.

+ [struct 是值类型]A struct is a value type. When a struct is created, the variable to which the struct is assigned holds the struct's actual data. When the struct is assigned to a new variable, it's copied. The new variable and the original variable therefore contain two separate copies of the same data. Changes made to one copy don't affect the other copy.
```c#

     namespace Wei
     {
         public class HelloMain
         {
             static int Main(string[] args)
             {
                 Person a_p = new Person("wang", 1);
                 System.Console.WriteLine(a_p);
     
                 Person a_p2 = a_p;
                 System.Console.WriteLine(a_p2);
     
                 a_p.setName("wang_modified");
                 System.Console.WriteLine(a_p);
     
                 System.Console.WriteLine(a_p2);
     
                 return 0;
             }
     
         }
     
         public struct Person
         {
             public string name { get;set; }
             public int age { get; set;}
             public Person(string name1, int age1)
             {
                 name = name1;
                 age = age1;
             }
     
             public  void setName(string theName)
             {
                 name = theName;
             }
     
             public override string ToString() => $"({name}, {age})";
         }
     }
     // 输出
     wei@Berries-Wang:~/WorkSpace/Open_Source/Microsoft-DotNet/002.Learn_Programs/000.CSharp_Grammar_01$ /home/wei/WorkSpace/Open_Source/Microsoft-DotNet/000.SOURCE_CODE/000.DotNet-RELEASE-V8.0.7/dotnet-8.0.7/artifacts/x64/Release/dotnet-sdk-wei/dotnet run 
     (wang, 1)
     (wang, 1)
     (wang_modified, 1)
     (wang, 1)
```

+ [Record 可以是值类型；也可以是引用类型]Record types may be either reference types (record class) or value types (record struct). Record types contain methods that support value-equality.

+ In general, classes are used to model more complex behavior. Classes typically store data that is intended to be modified after a class object is created. Structs are best suited for small data structures. Structs typically store data that isn't intended to be modified after the struct is created. Record types are data structures with additional compiler synthesized members. Records typically store data that isn't intended to be modified after the object is created.(一般来说，类用于为更复杂的行为建模。类通常存储在创建类对象之后要修改的数据。结构体最适合小型数据结构。结构体通常存储在结构体创建后不打算修改的数据。记录类型是具有附加编译器合成成员的数据结构。记录通常存储在对象创建后不打算修改的数据。)

#### Value Type(值类型)
Value types derive from System.ValueType, which derives from System.Object. Types that derive from System.ValueType have special behavior in the CLR. Value type variables directly contain their values. The memory for a struct is allocated inline in whatever context the variable is declared. There's no separate heap allocation or garbage collection overhead for value-type variables. You can declare record struct types that are value types and include the synthesized members for records.(值类型派生自System.ValueType，派生自System.Object。派生自System.ValueType的类型在CLR中有特殊的行为。值类型变量直接包含它们的值。结构体的内存在声明变量的任何上下文中都是内联分配的。对于值类型变量，没有单独的堆分配或垃圾收集开销。您可以声明值类型的记录结构类型，并包含记录的合成成员。)
> 值类型没有GC处理,内联分配

There are two categories of value types: struct and enum.

Value types are sealed. You can't derive a type from any value type, for example System.Int32. You can't define a struct to inherit from any user-defined class or struct because a struct can only inherit from System.ValueType. However, a struct can implement one or more interfaces. You can cast a struct type to any interface type that it implements. This cast causes a boxing operation to wrap the struct inside a reference type object on the managed heap. Boxing operations occur when you pass a value type to a method that takes a System.Object or any interface type as an input parameter. For more information, see [Boxing and Unboxing](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/types/boxing-and-unboxing).(值类型是密封的。不能从任何值类型派生类型，例如System.Int32.你不能定义一个结构来继承用户定义的类或结构，因为结构只能继承System.ValueType.然而，一个结构体可以实现一个或多个接口。可以将结构类型强制转换为他实现的任何接口类型。此强制转换导致装箱操作将结构体包装在托管在堆上的引用类型对象中。当您将值类型传递给以System为参数的方法时，就会发生装箱操作。对象或任何接口类型作为输入参数。有关信息，详见:Boxing and Unboxing)

You use the struct keyword to create your own custom value types. Typically, a struct is used as a container for a small set of related variables, as shown in the following example:(您可以使用struct关键字创建自己的自定义值类型。通常，结构体用作一小部分相关变量的容器，如下例所示:)
```c#
  public struct Coords
  {
      public int x, y;
  
      public Coords(int p1, int p2)
      {
          x = p1;
          y = p2;
      }
  }
```

The other category of value types is enum. An enum defines a set of named integral constants. For example, the System.IO.FileMode enumeration in the .NET class library contains a set of named constant integers that specify how a file should be opened. It's defined as shown in the following example:(另一类值类型是enum。枚举定义了一组命名的整型常量。例如，. net类库中的System.IO.FileMode枚举包含一组指定文件应该如何打开的命名常量整数。其定义如下例所示:)
```c#
  public enum FileMode
  {
      CreateNew = 1,
      Create = 2,
      Open = 3,
      OpenOrCreate = 4,
      Truncate = 5,
      Append = 6,
  }
```
- All enums inherit from System.Enum, which inherits from System.ValueType. All the rules that apply to structs also apply to enums. For more information about enums, see [Enumeration types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/enum).

---

#### Reference types
A type that is defined as a class, record, delegate, array, or interface is a reference type.

When declaring a variable of a reference type, it contains the value null until you assign it with an instance of that type or create one using the new operator. Creation and assignment of a class are demonstrated in the following example:
```c#
  
  MyClass myClass = new MyClass();
  MyClass myClass2 = myClass;

```

[接口不能被实例化]An interface cannot be directly instantiated using the new operator. Instead, create and assign an instance of a class that implements the interface. Consider the following example:
```c#
   MyClass myClass = new MyClass();

   // Declare and assign using an existing value.
   IMyInterface myInterface = myClass;
   
   // Or create and assign a value in a single statement.
   IMyInterface myInterface2 = new MyClass();
```

When the object is created, the memory is allocated on the managed heap. The variable holds only a reference to the location of the object. Types on the managed heap require overhead both when they're allocated and when they're reclaimed. Garbage collection is the automatic memory management functionality of the CLR, which performs the reclamation. However, garbage collection is also highly optimized, and in most scenarios it doesn't create a performance issue. For more information about garbage collection, see [Automatic Memory Management](https://learn.microsoft.com/en-us/dotnet/standard/automatic-memory-management).(在创建对象时，在托管堆上分配内存。变量只保存对对象位置的引用。托管堆上的类型在分配和回收时都需要开销。垃圾收集是CLR的自动内存管理功能，它执行回收。然而，垃圾收集也是高度优化的，在大多数情况下，它不会产生性能问题。有关垃圾收集的详细信息，请参见自动内存管理。)

All arrays are reference types, even if their elements are value types. Arrays implicitly derive from the System.Array class. You declare and use them with the simplified syntax that is provided by C#, as shown in the following example:
```c#
   // Declare and initialize an array of integers.
   int[] nums = [1, 2, 3, 4, 5];
   
   // Access an instance property of System.Array.
   int len = nums.Length;
```

Reference types fully support inheritance. When you create a class, you can inherit from any other interface or class that isn't defined as sealed. Other classes can inherit from your class and override your virtual methods. For more information about how to create your own classes, see Classes, structs, and records. For more information about inheritance and virtual methods, see Inheritance.(引用类型完全支持继承。当您创建一个类时，您可以继承任何其他未定义为密封的接口或类。其他类可以继承您的类并覆盖您的虚方法。有关如何创建自己的类的更多信息，请参见类、结构和记录。有关继承和虚方法的更多信息，请参见继承。)

---

#### Types of literal values (文字值的类型)
In C#, literal values receive a type from the compiler. You can specify how a numeric literal should be typed by appending a letter to the end of the number. For example, to specify that the value 4.56 should be treated as a float, append an "f" or "F" after the number: 4.56f. If no letter is appended, the compiler will infer a type for the literal. For more information about which types can be specified with letter suffixes, see Integral numeric types and Floating-point numeric types.(在c#中，文字值从编译器接收类型。您可以通过在数字末尾附加一个字母来指定数字文本的键入方式。例如，要指定值4.56应被视为浮点数，请在数字:4.56f后附加“f”或“f”。如果没有附加字母，编译器将推断文本的类型。有关可以用字母后缀指定哪些类型的详细信息，请参阅整型数值类型和浮点型数值类型。)

Because literals are typed, and all types derive ultimately from System.Object, you can write and compile code such as the following code:(因为字面量是类型化的，所有类型最终都来自System.Object，您可以编写和编译如下代码:)
```c#
   
   string s = "The answer is " + 5.ToString();
   // Outputs: "The answer is 5"
   Console.WriteLine(s);
   
   Type type = 12345.GetType();
   // Outputs: "System.Int32"
   Console.WriteLine(type);

```

---

#### Generic types (泛型)
A type can be declared with one or more type parameters that serve as a placeholder for the actual type (the concrete type). Client code provides the concrete type when it creates an instance of the type. Such types are called generic types. For example, the .NET type System.Collections.Generic.List<T> has one type parameter that by convention is given the name T. When you create an instance of the type, you specify the type of the objects that the list will contain, for example, string:（可以用一个或多个类型参数声明类型，这些类型参数充当实际类型(具体类型)的占位符。客户端代码在创建类型实例时提供具体类型。这种类型称为泛型类型。例如，.net类型System.Collections.Generic.List\<T\>有一个类型参数，按照约定命名为T。当创建该类型的实例时，指定列表将包含的对象的类型，例如string:）
```c#
   List<string> stringList = new List<string>();
   stringList.Add("String example");
   // compile time error adding a type other than a string:
   stringList.Add(4);
```

The use of the type parameter makes it possible to reuse the same class to hold any type of element, without having to convert each element to object. Generic collection classes are called strongly typed collections because the compiler knows the specific type of the collection's elements and can raise an error at compile time if, for example, you try to add an integer to the stringList object in the previous example. For more information, see [Generics](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/generics).(使用类型参数可以重用同一个类来保存任何类型的元素，而不必将每个元素转换为对象。泛型集合类被称为强类型集合，因为编译器知道集合元素的特定类型，并且在编译时可能引发错误，例如，如果您尝试在前面的示例中向stringList对象添加一个整数。有关更多信息，请参见泛型。)
> 泛型集合类 被称为 强类型集合

---

#### Implicit types, anonymous types, and nullable value types
You can implicitly type a local variable (but not class members) by using the var keyword. The variable still receives a type at compile time, but the type is provided by the compiler. For more information, see [Implicitly Typed Local Variables](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables).（可以使用var关键字隐式地键入局部变量(但不能键入类成员)。该变量在编译时仍然接收类型，但该类型由编译器提供。有关更多信息，请参见隐式类型化局部变量。）

It can be inconvenient to create a named type for simple sets of related values that you don't intend to store or pass outside method boundaries. You can create anonymous types for this purpose. For more information, see [Anonymous Types](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/types/anonymous-types).(为不打算存储或传递到方法边界之外的简单相关值集创建命名类型可能会很不方便。您可以为此目的创建匿名类型。有关详细信息，请参见匿名类型。)

Ordinary value types can't have a value of null. However, you can create nullable value types by appending a ? after the type. For example, int? is an int type that can also have the value null. Nullable value types are instances of the generic struct type System.Nullable\<T\>. Nullable value types are especially useful when you're passing data to and from databases in which numeric values might be null. For more information, see [Nullable value types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types).(普通值类型的值不能为null。但是，您可以通过附加?键入后。例如，int?是一个int类型，其值也可以为null。可空值类型是泛型结构类型System.Nullable\<T\>的实例。可空值类型在向数据库传递数据或从数据库传递数据时特别有用，其中的数值可能为空。有关更多信息，请参见可空值类型。)
```c#
     static int Main(string[] args)
        {
           // error CS0037: Cannot convert null to 'int' because it is a non-nullable value type
           int a = null;

           // OK , 正常执行
           int ?b=null;

           System.Console.WriteLine(b); // output: 无输出

            return 0;
        }

```

---

#### Compile-time type and run-time type
A variable can have different compile-time and run-time types. The compile-time type is the declared or inferred type of the variable in the source code. The run-time type is the type of the instance referred to by that variable. Often those two types are the same, as in the following example:（变量可以具有不同的编译时和运行时类型。编译时类型是源代码中变量的声明或推断类型。运行时类型是该变量引用的实例的类型。通常这两种类型是相同的，如下例所示:）
```c#
   string message = "This is a string of characters";
```

In other cases, the compile-time type is different, as shown in the following two examples:
```c#
   object anotherMessage = "This is another string of characters";
   IEnumerable<char> someCharacters = "abcdefghijklmnopqrstuvwxyz";
```

In both of the preceding examples, the run-time type is a string. The compile-time type is object in the first line, and IEnumerable\<char> in the second.(在前面的两个示例中，运行时类型都是字符串。编译时类型第一行是object，第二行是IEnumerable\<char>。)

If the two types are different for a variable, it's important to understand when the compile-time type and the run-time type apply. The compile-time type determines all the actions taken by the compiler. These compiler actions include method call resolution, overload resolution, and available implicit and explicit casts. The run-time type determines all actions that are resolved at run time. These run-time actions include dispatching virtual method calls, evaluating is and switch expressions, and other type testing APIs. To better understand how your code interacts with types, recognize which action applies to which type.(如果一个变量的两种类型不同，那么理解编译时类型和运行时类型何时应用是很重要的。编译时类型决定编译器采取的所有操作。这些编译器动作包括方法调用解析、重载解析以及可用的隐式和显式强制转换。运行时类型确定在运行时解析的所有操作。这些运行时操作包括调度虚拟方法调用、计算is和switch表达式，以及其他类型测试api。为了更好地理解代码如何与类型交互，请识别哪个操作应用于哪个类型。)
> 类比 Java中静态分派和动态分派

---

## 参考资料
1. [https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/struct)
2. [Value Type](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/value-types)